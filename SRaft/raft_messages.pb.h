// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: raft_messages.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_raft_5fmessages_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_raft_5fmessages_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>

#include "google/protobuf/port_def.inc"
#if PROTOBUF_VERSION < 4023000
#error "This file was generated by a newer version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please update"
#error "your headers."
#endif  // PROTOBUF_VERSION

#if 4023001 < PROTOBUF_MIN_PROTOC_VERSION
#error "This file was generated by an older version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please"
#error "regenerate this file with a newer version of protoc."
#endif  // PROTOBUF_MIN_PROTOC_VERSION
#include "google/protobuf/port_undef.inc"
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/unknown_field_set.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_raft_5fmessages_2eproto

PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_raft_5fmessages_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable
    descriptor_table_raft_5fmessages_2eproto;
namespace raft_messages {
class AppendEntriesRequest;
struct AppendEntriesRequestDefaultTypeInternal;
extern AppendEntriesRequestDefaultTypeInternal _AppendEntriesRequest_default_instance_;
class AppendEntriesResponse;
struct AppendEntriesResponseDefaultTypeInternal;
extern AppendEntriesResponseDefaultTypeInternal _AppendEntriesResponse_default_instance_;
class ConfRecord;
struct ConfRecordDefaultTypeInternal;
extern ConfRecordDefaultTypeInternal _ConfRecord_default_instance_;
class GetRequest;
struct GetRequestDefaultTypeInternal;
extern GetRequestDefaultTypeInternal _GetRequest_default_instance_;
class GetResponse;
struct GetResponseDefaultTypeInternal;
extern GetResponseDefaultTypeInternal _GetResponse_default_instance_;
class InstallSnapshotRequest;
struct InstallSnapshotRequestDefaultTypeInternal;
extern InstallSnapshotRequestDefaultTypeInternal _InstallSnapshotRequest_default_instance_;
class InstallSnapshotResponse;
struct InstallSnapshotResponseDefaultTypeInternal;
extern InstallSnapshotResponseDefaultTypeInternal _InstallSnapshotResponse_default_instance_;
class LogEntry;
struct LogEntryDefaultTypeInternal;
extern LogEntryDefaultTypeInternal _LogEntry_default_instance_;
class PersistRecord;
struct PersistRecordDefaultTypeInternal;
extern PersistRecordDefaultTypeInternal _PersistRecord_default_instance_;
class PutAppendRequest;
struct PutAppendRequestDefaultTypeInternal;
extern PutAppendRequestDefaultTypeInternal _PutAppendRequest_default_instance_;
class PutAppendResponse;
struct PutAppendResponseDefaultTypeInternal;
extern PutAppendResponseDefaultTypeInternal _PutAppendResponse_default_instance_;
class RequestVoteRequest;
struct RequestVoteRequestDefaultTypeInternal;
extern RequestVoteRequestDefaultTypeInternal _RequestVoteRequest_default_instance_;
class RequestVoteResponse;
struct RequestVoteResponseDefaultTypeInternal;
extern RequestVoteResponseDefaultTypeInternal _RequestVoteResponse_default_instance_;
}  // namespace raft_messages
PROTOBUF_NAMESPACE_OPEN
template <>
::raft_messages::AppendEntriesRequest* Arena::CreateMaybeMessage<::raft_messages::AppendEntriesRequest>(Arena*);
template <>
::raft_messages::AppendEntriesResponse* Arena::CreateMaybeMessage<::raft_messages::AppendEntriesResponse>(Arena*);
template <>
::raft_messages::ConfRecord* Arena::CreateMaybeMessage<::raft_messages::ConfRecord>(Arena*);
template <>
::raft_messages::GetRequest* Arena::CreateMaybeMessage<::raft_messages::GetRequest>(Arena*);
template <>
::raft_messages::GetResponse* Arena::CreateMaybeMessage<::raft_messages::GetResponse>(Arena*);
template <>
::raft_messages::InstallSnapshotRequest* Arena::CreateMaybeMessage<::raft_messages::InstallSnapshotRequest>(Arena*);
template <>
::raft_messages::InstallSnapshotResponse* Arena::CreateMaybeMessage<::raft_messages::InstallSnapshotResponse>(Arena*);
template <>
::raft_messages::LogEntry* Arena::CreateMaybeMessage<::raft_messages::LogEntry>(Arena*);
template <>
::raft_messages::PersistRecord* Arena::CreateMaybeMessage<::raft_messages::PersistRecord>(Arena*);
template <>
::raft_messages::PutAppendRequest* Arena::CreateMaybeMessage<::raft_messages::PutAppendRequest>(Arena*);
template <>
::raft_messages::PutAppendResponse* Arena::CreateMaybeMessage<::raft_messages::PutAppendResponse>(Arena*);
template <>
::raft_messages::RequestVoteRequest* Arena::CreateMaybeMessage<::raft_messages::RequestVoteRequest>(Arena*);
template <>
::raft_messages::RequestVoteResponse* Arena::CreateMaybeMessage<::raft_messages::RequestVoteResponse>(Arena*);
PROTOBUF_NAMESPACE_CLOSE

namespace raft_messages {

// ===================================================================


// -------------------------------------------------------------------

class LogEntry final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:raft_messages.LogEntry) */ {
 public:
  inline LogEntry() : LogEntry(nullptr) {}
  ~LogEntry() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR LogEntry(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LogEntry(const LogEntry& from);
  LogEntry(LogEntry&& from) noexcept
    : LogEntry() {
    *this = ::std::move(from);
  }

  inline LogEntry& operator=(const LogEntry& from) {
    CopyFrom(from);
    return *this;
  }
  inline LogEntry& operator=(LogEntry&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LogEntry& default_instance() {
    return *internal_default_instance();
  }
  static inline const LogEntry* internal_default_instance() {
    return reinterpret_cast<const LogEntry*>(
               &_LogEntry_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(LogEntry& a, LogEntry& b) {
    a.Swap(&b);
  }
  inline void Swap(LogEntry* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LogEntry* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LogEntry* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LogEntry>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LogEntry& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LogEntry& from) {
    LogEntry::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LogEntry* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "raft_messages.LogEntry";
  }
  protected:
  explicit LogEntry(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 4,
    kIndexFieldNumber = 1,
    kTermFieldNumber = 2,
    kCommandFieldNumber = 3,
  };
  // optional bytes data = 4;
  bool has_data() const;
  void clear_data() ;
  const std::string& data() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_data(Arg_&& arg, Args_... args);
  std::string* mutable_data();
  PROTOBUF_NODISCARD std::string* release_data();
  void set_allocated_data(std::string* ptr);

  private:
  const std::string& _internal_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data(
      const std::string& value);
  std::string* _internal_mutable_data();

  public:
  // required int64 index = 1;
  bool has_index() const;
  void clear_index() ;
  ::int64_t index() const;
  void set_index(::int64_t value);

  private:
  ::int64_t _internal_index() const;
  void _internal_set_index(::int64_t value);

  public:
  // required uint64 term = 2;
  bool has_term() const;
  void clear_term() ;
  ::uint64_t term() const;
  void set_term(::uint64_t value);

  private:
  ::uint64_t _internal_term() const;
  void _internal_set_term(::uint64_t value);

  public:
  // required int32 command = 3;
  bool has_command() const;
  void clear_command() ;
  ::int32_t command() const;
  void set_command(::int32_t value);

  private:
  ::int32_t _internal_command() const;
  void _internal_set_command(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:raft_messages.LogEntry)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  ::size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_;
    ::int64_t index_;
    ::uint64_t term_;
    ::int32_t command_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_raft_5fmessages_2eproto;
};// -------------------------------------------------------------------

class AppendEntriesRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:raft_messages.AppendEntriesRequest) */ {
 public:
  inline AppendEntriesRequest() : AppendEntriesRequest(nullptr) {}
  ~AppendEntriesRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR AppendEntriesRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AppendEntriesRequest(const AppendEntriesRequest& from);
  AppendEntriesRequest(AppendEntriesRequest&& from) noexcept
    : AppendEntriesRequest() {
    *this = ::std::move(from);
  }

  inline AppendEntriesRequest& operator=(const AppendEntriesRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline AppendEntriesRequest& operator=(AppendEntriesRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AppendEntriesRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const AppendEntriesRequest* internal_default_instance() {
    return reinterpret_cast<const AppendEntriesRequest*>(
               &_AppendEntriesRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(AppendEntriesRequest& a, AppendEntriesRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(AppendEntriesRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AppendEntriesRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AppendEntriesRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AppendEntriesRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AppendEntriesRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AppendEntriesRequest& from) {
    AppendEntriesRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AppendEntriesRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "raft_messages.AppendEntriesRequest";
  }
  protected:
  explicit AppendEntriesRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEntriesFieldNumber = 6,
    kNameFieldNumber = 1,
    kTermFieldNumber = 2,
    kPrevLogIndexFieldNumber = 3,
    kPrevLogTermFieldNumber = 4,
    kLeaderCommitFieldNumber = 5,
    kTimeFieldNumber = 7,
    kSeqFieldNumber = 8,
    kInitialFieldNumber = 9,
  };
  // repeated .raft_messages.LogEntry entries = 6;
  int entries_size() const;
  private:
  int _internal_entries_size() const;

  public:
  void clear_entries() ;
  ::raft_messages::LogEntry* mutable_entries(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::raft_messages::LogEntry >*
      mutable_entries();
  private:
  const ::raft_messages::LogEntry& _internal_entries(int index) const;
  ::raft_messages::LogEntry* _internal_add_entries();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::raft_messages::LogEntry>& _internal_entries() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::raft_messages::LogEntry>* _internal_mutable_entries();
  public:
  const ::raft_messages::LogEntry& entries(int index) const;
  ::raft_messages::LogEntry* add_entries();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::raft_messages::LogEntry >&
      entries() const;
  // required string name = 1;
  bool has_name() const;
  void clear_name() ;
  const std::string& name() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* ptr);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // required uint64 term = 2;
  bool has_term() const;
  void clear_term() ;
  ::uint64_t term() const;
  void set_term(::uint64_t value);

  private:
  ::uint64_t _internal_term() const;
  void _internal_set_term(::uint64_t value);

  public:
  // required int64 prev_log_index = 3;
  bool has_prev_log_index() const;
  void clear_prev_log_index() ;
  ::int64_t prev_log_index() const;
  void set_prev_log_index(::int64_t value);

  private:
  ::int64_t _internal_prev_log_index() const;
  void _internal_set_prev_log_index(::int64_t value);

  public:
  // required uint64 prev_log_term = 4;
  bool has_prev_log_term() const;
  void clear_prev_log_term() ;
  ::uint64_t prev_log_term() const;
  void set_prev_log_term(::uint64_t value);

  private:
  ::uint64_t _internal_prev_log_term() const;
  void _internal_set_prev_log_term(::uint64_t value);

  public:
  // required int64 leader_commit = 5;
  bool has_leader_commit() const;
  void clear_leader_commit() ;
  ::int64_t leader_commit() const;
  void set_leader_commit(::int64_t value);

  private:
  ::int64_t _internal_leader_commit() const;
  void _internal_set_leader_commit(::int64_t value);

  public:
  // required uint64 time = 7;
  bool has_time() const;
  void clear_time() ;
  ::uint64_t time() const;
  void set_time(::uint64_t value);

  private:
  ::uint64_t _internal_time() const;
  void _internal_set_time(::uint64_t value);

  public:
  // required uint64 seq = 8;
  bool has_seq() const;
  void clear_seq() ;
  ::uint64_t seq() const;
  void set_seq(::uint64_t value);

  private:
  ::uint64_t _internal_seq() const;
  void _internal_set_seq(::uint64_t value);

  public:
  // required bool initial = 9;
  bool has_initial() const;
  void clear_initial() ;
  bool initial() const;
  void set_initial(bool value);

  private:
  bool _internal_initial() const;
  void _internal_set_initial(bool value);

  public:
  // @@protoc_insertion_point(class_scope:raft_messages.AppendEntriesRequest)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  ::size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::raft_messages::LogEntry > entries_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::uint64_t term_;
    ::int64_t prev_log_index_;
    ::uint64_t prev_log_term_;
    ::int64_t leader_commit_;
    ::uint64_t time_;
    ::uint64_t seq_;
    bool initial_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_raft_5fmessages_2eproto;
};// -------------------------------------------------------------------

class AppendEntriesResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:raft_messages.AppendEntriesResponse) */ {
 public:
  inline AppendEntriesResponse() : AppendEntriesResponse(nullptr) {}
  ~AppendEntriesResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR AppendEntriesResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AppendEntriesResponse(const AppendEntriesResponse& from);
  AppendEntriesResponse(AppendEntriesResponse&& from) noexcept
    : AppendEntriesResponse() {
    *this = ::std::move(from);
  }

  inline AppendEntriesResponse& operator=(const AppendEntriesResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline AppendEntriesResponse& operator=(AppendEntriesResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AppendEntriesResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const AppendEntriesResponse* internal_default_instance() {
    return reinterpret_cast<const AppendEntriesResponse*>(
               &_AppendEntriesResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(AppendEntriesResponse& a, AppendEntriesResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(AppendEntriesResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AppendEntriesResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AppendEntriesResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AppendEntriesResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AppendEntriesResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AppendEntriesResponse& from) {
    AppendEntriesResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AppendEntriesResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "raft_messages.AppendEntriesResponse";
  }
  protected:
  explicit AppendEntriesResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kTermFieldNumber = 2,
    kLastLogIndexFieldNumber = 4,
    kLastLogTermFieldNumber = 5,
    kTimeFieldNumber = 6,
    kSeqFieldNumber = 7,
    kSuccessFieldNumber = 3,
  };
  // required string name = 1;
  bool has_name() const;
  void clear_name() ;
  const std::string& name() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* ptr);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // required uint64 term = 2;
  bool has_term() const;
  void clear_term() ;
  ::uint64_t term() const;
  void set_term(::uint64_t value);

  private:
  ::uint64_t _internal_term() const;
  void _internal_set_term(::uint64_t value);

  public:
  // required int64 last_log_index = 4;
  bool has_last_log_index() const;
  void clear_last_log_index() ;
  ::int64_t last_log_index() const;
  void set_last_log_index(::int64_t value);

  private:
  ::int64_t _internal_last_log_index() const;
  void _internal_set_last_log_index(::int64_t value);

  public:
  // required uint64 last_log_term = 5;
  bool has_last_log_term() const;
  void clear_last_log_term() ;
  ::uint64_t last_log_term() const;
  void set_last_log_term(::uint64_t value);

  private:
  ::uint64_t _internal_last_log_term() const;
  void _internal_set_last_log_term(::uint64_t value);

  public:
  // required uint64 time = 6;
  bool has_time() const;
  void clear_time() ;
  ::uint64_t time() const;
  void set_time(::uint64_t value);

  private:
  ::uint64_t _internal_time() const;
  void _internal_set_time(::uint64_t value);

  public:
  // required uint64 seq = 7;
  bool has_seq() const;
  void clear_seq() ;
  ::uint64_t seq() const;
  void set_seq(::uint64_t value);

  private:
  ::uint64_t _internal_seq() const;
  void _internal_set_seq(::uint64_t value);

  public:
  // required bool success = 3;
  bool has_success() const;
  void clear_success() ;
  bool success() const;
  void set_success(bool value);

  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);

  public:
  // @@protoc_insertion_point(class_scope:raft_messages.AppendEntriesResponse)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  ::size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::uint64_t term_;
    ::int64_t last_log_index_;
    ::uint64_t last_log_term_;
    ::uint64_t time_;
    ::uint64_t seq_;
    bool success_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_raft_5fmessages_2eproto;
};// -------------------------------------------------------------------

class RequestVoteRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:raft_messages.RequestVoteRequest) */ {
 public:
  inline RequestVoteRequest() : RequestVoteRequest(nullptr) {}
  ~RequestVoteRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR RequestVoteRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RequestVoteRequest(const RequestVoteRequest& from);
  RequestVoteRequest(RequestVoteRequest&& from) noexcept
    : RequestVoteRequest() {
    *this = ::std::move(from);
  }

  inline RequestVoteRequest& operator=(const RequestVoteRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline RequestVoteRequest& operator=(RequestVoteRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RequestVoteRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const RequestVoteRequest* internal_default_instance() {
    return reinterpret_cast<const RequestVoteRequest*>(
               &_RequestVoteRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(RequestVoteRequest& a, RequestVoteRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(RequestVoteRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RequestVoteRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RequestVoteRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RequestVoteRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RequestVoteRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RequestVoteRequest& from) {
    RequestVoteRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RequestVoteRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "raft_messages.RequestVoteRequest";
  }
  protected:
  explicit RequestVoteRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kTermFieldNumber = 2,
    kLastLogIndexFieldNumber = 3,
    kLastLogTermFieldNumber = 4,
    kTimeFieldNumber = 5,
    kSeqFieldNumber = 6,
    kInitialFieldNumber = 7,
  };
  // required string name = 1;
  bool has_name() const;
  void clear_name() ;
  const std::string& name() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* ptr);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // required uint64 term = 2;
  bool has_term() const;
  void clear_term() ;
  ::uint64_t term() const;
  void set_term(::uint64_t value);

  private:
  ::uint64_t _internal_term() const;
  void _internal_set_term(::uint64_t value);

  public:
  // required int64 last_log_index = 3;
  bool has_last_log_index() const;
  void clear_last_log_index() ;
  ::int64_t last_log_index() const;
  void set_last_log_index(::int64_t value);

  private:
  ::int64_t _internal_last_log_index() const;
  void _internal_set_last_log_index(::int64_t value);

  public:
  // required uint64 last_log_term = 4;
  bool has_last_log_term() const;
  void clear_last_log_term() ;
  ::uint64_t last_log_term() const;
  void set_last_log_term(::uint64_t value);

  private:
  ::uint64_t _internal_last_log_term() const;
  void _internal_set_last_log_term(::uint64_t value);

  public:
  // required uint64 time = 5;
  bool has_time() const;
  void clear_time() ;
  ::uint64_t time() const;
  void set_time(::uint64_t value);

  private:
  ::uint64_t _internal_time() const;
  void _internal_set_time(::uint64_t value);

  public:
  // required uint64 seq = 6;
  bool has_seq() const;
  void clear_seq() ;
  ::uint64_t seq() const;
  void set_seq(::uint64_t value);

  private:
  ::uint64_t _internal_seq() const;
  void _internal_set_seq(::uint64_t value);

  public:
  // required bool initial = 7;
  bool has_initial() const;
  void clear_initial() ;
  bool initial() const;
  void set_initial(bool value);

  private:
  bool _internal_initial() const;
  void _internal_set_initial(bool value);

  public:
  // @@protoc_insertion_point(class_scope:raft_messages.RequestVoteRequest)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  ::size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::uint64_t term_;
    ::int64_t last_log_index_;
    ::uint64_t last_log_term_;
    ::uint64_t time_;
    ::uint64_t seq_;
    bool initial_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_raft_5fmessages_2eproto;
};// -------------------------------------------------------------------

class RequestVoteResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:raft_messages.RequestVoteResponse) */ {
 public:
  inline RequestVoteResponse() : RequestVoteResponse(nullptr) {}
  ~RequestVoteResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR RequestVoteResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RequestVoteResponse(const RequestVoteResponse& from);
  RequestVoteResponse(RequestVoteResponse&& from) noexcept
    : RequestVoteResponse() {
    *this = ::std::move(from);
  }

  inline RequestVoteResponse& operator=(const RequestVoteResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline RequestVoteResponse& operator=(RequestVoteResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RequestVoteResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const RequestVoteResponse* internal_default_instance() {
    return reinterpret_cast<const RequestVoteResponse*>(
               &_RequestVoteResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(RequestVoteResponse& a, RequestVoteResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(RequestVoteResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RequestVoteResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RequestVoteResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RequestVoteResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RequestVoteResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RequestVoteResponse& from) {
    RequestVoteResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RequestVoteResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "raft_messages.RequestVoteResponse";
  }
  protected:
  explicit RequestVoteResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kTermFieldNumber = 2,
    kTimeFieldNumber = 4,
    kSeqFieldNumber = 5,
    kVoteGrantedFieldNumber = 3,
  };
  // required string name = 1;
  bool has_name() const;
  void clear_name() ;
  const std::string& name() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* ptr);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // required uint64 term = 2;
  bool has_term() const;
  void clear_term() ;
  ::uint64_t term() const;
  void set_term(::uint64_t value);

  private:
  ::uint64_t _internal_term() const;
  void _internal_set_term(::uint64_t value);

  public:
  // required uint64 time = 4;
  bool has_time() const;
  void clear_time() ;
  ::uint64_t time() const;
  void set_time(::uint64_t value);

  private:
  ::uint64_t _internal_time() const;
  void _internal_set_time(::uint64_t value);

  public:
  // required uint64 seq = 5;
  bool has_seq() const;
  void clear_seq() ;
  ::uint64_t seq() const;
  void set_seq(::uint64_t value);

  private:
  ::uint64_t _internal_seq() const;
  void _internal_set_seq(::uint64_t value);

  public:
  // required bool vote_granted = 3;
  bool has_vote_granted() const;
  void clear_vote_granted() ;
  bool vote_granted() const;
  void set_vote_granted(bool value);

  private:
  bool _internal_vote_granted() const;
  void _internal_set_vote_granted(bool value);

  public:
  // @@protoc_insertion_point(class_scope:raft_messages.RequestVoteResponse)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  ::size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::uint64_t term_;
    ::uint64_t time_;
    ::uint64_t seq_;
    bool vote_granted_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_raft_5fmessages_2eproto;
};// -------------------------------------------------------------------

class InstallSnapshotRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:raft_messages.InstallSnapshotRequest) */ {
 public:
  inline InstallSnapshotRequest() : InstallSnapshotRequest(nullptr) {}
  ~InstallSnapshotRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR InstallSnapshotRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  InstallSnapshotRequest(const InstallSnapshotRequest& from);
  InstallSnapshotRequest(InstallSnapshotRequest&& from) noexcept
    : InstallSnapshotRequest() {
    *this = ::std::move(from);
  }

  inline InstallSnapshotRequest& operator=(const InstallSnapshotRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline InstallSnapshotRequest& operator=(InstallSnapshotRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InstallSnapshotRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const InstallSnapshotRequest* internal_default_instance() {
    return reinterpret_cast<const InstallSnapshotRequest*>(
               &_InstallSnapshotRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(InstallSnapshotRequest& a, InstallSnapshotRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(InstallSnapshotRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InstallSnapshotRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InstallSnapshotRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<InstallSnapshotRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const InstallSnapshotRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const InstallSnapshotRequest& from) {
    InstallSnapshotRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InstallSnapshotRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "raft_messages.InstallSnapshotRequest";
  }
  protected:
  explicit InstallSnapshotRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 2,
    kDataFieldNumber = 6,
    kTermFieldNumber = 1,
    kLastIncludedIndexFieldNumber = 3,
    kLastIncludedTermFieldNumber = 4,
    kTimeFieldNumber = 7,
    kSeqFieldNumber = 8,
    kInitialFieldNumber = 9,
  };
  // required string name = 2;
  bool has_name() const;
  void clear_name() ;
  const std::string& name() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* ptr);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // required bytes data = 6;
  bool has_data() const;
  void clear_data() ;
  const std::string& data() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_data(Arg_&& arg, Args_... args);
  std::string* mutable_data();
  PROTOBUF_NODISCARD std::string* release_data();
  void set_allocated_data(std::string* ptr);

  private:
  const std::string& _internal_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data(
      const std::string& value);
  std::string* _internal_mutable_data();

  public:
  // required uint64 term = 1;
  bool has_term() const;
  void clear_term() ;
  ::uint64_t term() const;
  void set_term(::uint64_t value);

  private:
  ::uint64_t _internal_term() const;
  void _internal_set_term(::uint64_t value);

  public:
  // required int64 last_included_index = 3;
  bool has_last_included_index() const;
  void clear_last_included_index() ;
  ::int64_t last_included_index() const;
  void set_last_included_index(::int64_t value);

  private:
  ::int64_t _internal_last_included_index() const;
  void _internal_set_last_included_index(::int64_t value);

  public:
  // required int64 last_included_term = 4;
  bool has_last_included_term() const;
  void clear_last_included_term() ;
  ::int64_t last_included_term() const;
  void set_last_included_term(::int64_t value);

  private:
  ::int64_t _internal_last_included_term() const;
  void _internal_set_last_included_term(::int64_t value);

  public:
  // required uint64 time = 7;
  bool has_time() const;
  void clear_time() ;
  ::uint64_t time() const;
  void set_time(::uint64_t value);

  private:
  ::uint64_t _internal_time() const;
  void _internal_set_time(::uint64_t value);

  public:
  // required uint64 seq = 8;
  bool has_seq() const;
  void clear_seq() ;
  ::uint64_t seq() const;
  void set_seq(::uint64_t value);

  private:
  ::uint64_t _internal_seq() const;
  void _internal_set_seq(::uint64_t value);

  public:
  // required bool initial = 9;
  bool has_initial() const;
  void clear_initial() ;
  bool initial() const;
  void set_initial(bool value);

  private:
  bool _internal_initial() const;
  void _internal_set_initial(bool value);

  public:
  // @@protoc_insertion_point(class_scope:raft_messages.InstallSnapshotRequest)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  ::size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_;
    ::uint64_t term_;
    ::int64_t last_included_index_;
    ::int64_t last_included_term_;
    ::uint64_t time_;
    ::uint64_t seq_;
    bool initial_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_raft_5fmessages_2eproto;
};// -------------------------------------------------------------------

class InstallSnapshotResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:raft_messages.InstallSnapshotResponse) */ {
 public:
  inline InstallSnapshotResponse() : InstallSnapshotResponse(nullptr) {}
  ~InstallSnapshotResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR InstallSnapshotResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  InstallSnapshotResponse(const InstallSnapshotResponse& from);
  InstallSnapshotResponse(InstallSnapshotResponse&& from) noexcept
    : InstallSnapshotResponse() {
    *this = ::std::move(from);
  }

  inline InstallSnapshotResponse& operator=(const InstallSnapshotResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline InstallSnapshotResponse& operator=(InstallSnapshotResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InstallSnapshotResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const InstallSnapshotResponse* internal_default_instance() {
    return reinterpret_cast<const InstallSnapshotResponse*>(
               &_InstallSnapshotResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(InstallSnapshotResponse& a, InstallSnapshotResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(InstallSnapshotResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InstallSnapshotResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InstallSnapshotResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<InstallSnapshotResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const InstallSnapshotResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const InstallSnapshotResponse& from) {
    InstallSnapshotResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InstallSnapshotResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "raft_messages.InstallSnapshotResponse";
  }
  protected:
  explicit InstallSnapshotResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 2,
    kTermFieldNumber = 1,
    kLastIncludedIndexFieldNumber = 3,
    kLastIncludedTermFieldNumber = 4,
    kTimeFieldNumber = 6,
    kSeqFieldNumber = 7,
    kSuccessFieldNumber = 5,
  };
  // required string name = 2;
  bool has_name() const;
  void clear_name() ;
  const std::string& name() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* ptr);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // required uint64 term = 1;
  bool has_term() const;
  void clear_term() ;
  ::uint64_t term() const;
  void set_term(::uint64_t value);

  private:
  ::uint64_t _internal_term() const;
  void _internal_set_term(::uint64_t value);

  public:
  // required int64 last_included_index = 3;
  bool has_last_included_index() const;
  void clear_last_included_index() ;
  ::int64_t last_included_index() const;
  void set_last_included_index(::int64_t value);

  private:
  ::int64_t _internal_last_included_index() const;
  void _internal_set_last_included_index(::int64_t value);

  public:
  // required int64 last_included_term = 4;
  bool has_last_included_term() const;
  void clear_last_included_term() ;
  ::int64_t last_included_term() const;
  void set_last_included_term(::int64_t value);

  private:
  ::int64_t _internal_last_included_term() const;
  void _internal_set_last_included_term(::int64_t value);

  public:
  // required uint64 time = 6;
  bool has_time() const;
  void clear_time() ;
  ::uint64_t time() const;
  void set_time(::uint64_t value);

  private:
  ::uint64_t _internal_time() const;
  void _internal_set_time(::uint64_t value);

  public:
  // required uint64 seq = 7;
  bool has_seq() const;
  void clear_seq() ;
  ::uint64_t seq() const;
  void set_seq(::uint64_t value);

  private:
  ::uint64_t _internal_seq() const;
  void _internal_set_seq(::uint64_t value);

  public:
  // required bool success = 5;
  bool has_success() const;
  void clear_success() ;
  bool success() const;
  void set_success(bool value);

  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);

  public:
  // @@protoc_insertion_point(class_scope:raft_messages.InstallSnapshotResponse)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  ::size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::uint64_t term_;
    ::int64_t last_included_index_;
    ::int64_t last_included_term_;
    ::uint64_t time_;
    ::uint64_t seq_;
    bool success_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_raft_5fmessages_2eproto;
};// -------------------------------------------------------------------

class ConfRecord final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:raft_messages.ConfRecord) */ {
 public:
  inline ConfRecord() : ConfRecord(nullptr) {}
  ~ConfRecord() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ConfRecord(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ConfRecord(const ConfRecord& from);
  ConfRecord(ConfRecord&& from) noexcept
    : ConfRecord() {
    *this = ::std::move(from);
  }

  inline ConfRecord& operator=(const ConfRecord& from) {
    CopyFrom(from);
    return *this;
  }
  inline ConfRecord& operator=(ConfRecord&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ConfRecord& default_instance() {
    return *internal_default_instance();
  }
  static inline const ConfRecord* internal_default_instance() {
    return reinterpret_cast<const ConfRecord*>(
               &_ConfRecord_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(ConfRecord& a, ConfRecord& b) {
    a.Swap(&b);
  }
  inline void Swap(ConfRecord* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ConfRecord* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ConfRecord* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ConfRecord>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ConfRecord& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ConfRecord& from) {
    ConfRecord::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ConfRecord* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "raft_messages.ConfRecord";
  }
  protected:
  explicit ConfRecord(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPeersFieldNumber = 1,
    kIndexFieldNumber = 2,
    kIndex2FieldNumber = 3,
    kStateFieldNumber = 4,
  };
  // required string peers = 1;
  bool has_peers() const;
  void clear_peers() ;
  const std::string& peers() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_peers(Arg_&& arg, Args_... args);
  std::string* mutable_peers();
  PROTOBUF_NODISCARD std::string* release_peers();
  void set_allocated_peers(std::string* ptr);

  private:
  const std::string& _internal_peers() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_peers(
      const std::string& value);
  std::string* _internal_mutable_peers();

  public:
  // required int64 index = 2;
  bool has_index() const;
  void clear_index() ;
  ::int64_t index() const;
  void set_index(::int64_t value);

  private:
  ::int64_t _internal_index() const;
  void _internal_set_index(::int64_t value);

  public:
  // required int64 index2 = 3;
  bool has_index2() const;
  void clear_index2() ;
  ::int64_t index2() const;
  void set_index2(::int64_t value);

  private:
  ::int64_t _internal_index2() const;
  void _internal_set_index2(::int64_t value);

  public:
  // required int64 state = 4;
  bool has_state() const;
  void clear_state() ;
  ::int64_t state() const;
  void set_state(::int64_t value);

  private:
  ::int64_t _internal_state() const;
  void _internal_set_state(::int64_t value);

  public:
  // @@protoc_insertion_point(class_scope:raft_messages.ConfRecord)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  ::size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr peers_;
    ::int64_t index_;
    ::int64_t index2_;
    ::int64_t state_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_raft_5fmessages_2eproto;
};// -------------------------------------------------------------------

class PersistRecord final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:raft_messages.PersistRecord) */ {
 public:
  inline PersistRecord() : PersistRecord(nullptr) {}
  ~PersistRecord() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR PersistRecord(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PersistRecord(const PersistRecord& from);
  PersistRecord(PersistRecord&& from) noexcept
    : PersistRecord() {
    *this = ::std::move(from);
  }

  inline PersistRecord& operator=(const PersistRecord& from) {
    CopyFrom(from);
    return *this;
  }
  inline PersistRecord& operator=(PersistRecord&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PersistRecord& default_instance() {
    return *internal_default_instance();
  }
  static inline const PersistRecord* internal_default_instance() {
    return reinterpret_cast<const PersistRecord*>(
               &_PersistRecord_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(PersistRecord& a, PersistRecord& b) {
    a.Swap(&b);
  }
  inline void Swap(PersistRecord* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PersistRecord* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PersistRecord* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PersistRecord>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PersistRecord& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PersistRecord& from) {
    PersistRecord::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PersistRecord* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "raft_messages.PersistRecord";
  }
  protected:
  explicit PersistRecord(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEntriesFieldNumber = 4,
    kNameFieldNumber = 2,
    kVoteForFieldNumber = 3,
    kConfRecordFieldNumber = 5,
    kTermFieldNumber = 1,
    kLastSeqFieldNumber = 6,
  };
  // repeated .raft_messages.LogEntry entries = 4;
  int entries_size() const;
  private:
  int _internal_entries_size() const;

  public:
  void clear_entries() ;
  ::raft_messages::LogEntry* mutable_entries(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::raft_messages::LogEntry >*
      mutable_entries();
  private:
  const ::raft_messages::LogEntry& _internal_entries(int index) const;
  ::raft_messages::LogEntry* _internal_add_entries();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::raft_messages::LogEntry>& _internal_entries() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::raft_messages::LogEntry>* _internal_mutable_entries();
  public:
  const ::raft_messages::LogEntry& entries(int index) const;
  ::raft_messages::LogEntry* add_entries();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::raft_messages::LogEntry >&
      entries() const;
  // required string name = 2;
  bool has_name() const;
  void clear_name() ;
  const std::string& name() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* ptr);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // required string vote_for = 3;
  bool has_vote_for() const;
  void clear_vote_for() ;
  const std::string& vote_for() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_vote_for(Arg_&& arg, Args_... args);
  std::string* mutable_vote_for();
  PROTOBUF_NODISCARD std::string* release_vote_for();
  void set_allocated_vote_for(std::string* ptr);

  private:
  const std::string& _internal_vote_for() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_vote_for(
      const std::string& value);
  std::string* _internal_mutable_vote_for();

  public:
  // optional .raft_messages.ConfRecord conf_record = 5;
  bool has_conf_record() const;
  void clear_conf_record() ;
  const ::raft_messages::ConfRecord& conf_record() const;
  PROTOBUF_NODISCARD ::raft_messages::ConfRecord* release_conf_record();
  ::raft_messages::ConfRecord* mutable_conf_record();
  void set_allocated_conf_record(::raft_messages::ConfRecord* conf_record);
  private:
  const ::raft_messages::ConfRecord& _internal_conf_record() const;
  ::raft_messages::ConfRecord* _internal_mutable_conf_record();
  public:
  void unsafe_arena_set_allocated_conf_record(
      ::raft_messages::ConfRecord* conf_record);
  ::raft_messages::ConfRecord* unsafe_arena_release_conf_record();
  // required uint64 term = 1;
  bool has_term() const;
  void clear_term() ;
  ::uint64_t term() const;
  void set_term(::uint64_t value);

  private:
  ::uint64_t _internal_term() const;
  void _internal_set_term(::uint64_t value);

  public:
  // required uint64 last_seq = 6;
  bool has_last_seq() const;
  void clear_last_seq() ;
  ::uint64_t last_seq() const;
  void set_last_seq(::uint64_t value);

  private:
  ::uint64_t _internal_last_seq() const;
  void _internal_set_last_seq(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:raft_messages.PersistRecord)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  ::size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::raft_messages::LogEntry > entries_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr vote_for_;
    ::raft_messages::ConfRecord* conf_record_;
    ::uint64_t term_;
    ::uint64_t last_seq_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_raft_5fmessages_2eproto;
};// -------------------------------------------------------------------

class PutAppendRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:raft_messages.PutAppendRequest) */ {
 public:
  inline PutAppendRequest() : PutAppendRequest(nullptr) {}
  ~PutAppendRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR PutAppendRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PutAppendRequest(const PutAppendRequest& from);
  PutAppendRequest(PutAppendRequest&& from) noexcept
    : PutAppendRequest() {
    *this = ::std::move(from);
  }

  inline PutAppendRequest& operator=(const PutAppendRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline PutAppendRequest& operator=(PutAppendRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PutAppendRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const PutAppendRequest* internal_default_instance() {
    return reinterpret_cast<const PutAppendRequest*>(
               &_PutAppendRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(PutAppendRequest& a, PutAppendRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(PutAppendRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PutAppendRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PutAppendRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PutAppendRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PutAppendRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PutAppendRequest& from) {
    PutAppendRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PutAppendRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "raft_messages.PutAppendRequest";
  }
  protected:
  explicit PutAppendRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKeyFieldNumber = 1,
    kValueFieldNumber = 2,
    kOpFieldNumber = 3,
    kClerkIDFieldNumber = 4,
    kCmdIndexFieldNumber = 5,
  };
  // required string key = 1;
  bool has_key() const;
  void clear_key() ;
  const std::string& key() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_key(Arg_&& arg, Args_... args);
  std::string* mutable_key();
  PROTOBUF_NODISCARD std::string* release_key();
  void set_allocated_key(std::string* ptr);

  private:
  const std::string& _internal_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_key(
      const std::string& value);
  std::string* _internal_mutable_key();

  public:
  // required string value = 2;
  bool has_value() const;
  void clear_value() ;
  const std::string& value() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_value(Arg_&& arg, Args_... args);
  std::string* mutable_value();
  PROTOBUF_NODISCARD std::string* release_value();
  void set_allocated_value(std::string* ptr);

  private:
  const std::string& _internal_value() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_value(
      const std::string& value);
  std::string* _internal_mutable_value();

  public:
  // required string op = 3;
  bool has_op() const;
  void clear_op() ;
  const std::string& op() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_op(Arg_&& arg, Args_... args);
  std::string* mutable_op();
  PROTOBUF_NODISCARD std::string* release_op();
  void set_allocated_op(std::string* ptr);

  private:
  const std::string& _internal_op() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_op(
      const std::string& value);
  std::string* _internal_mutable_op();

  public:
  // required int64 ClerkID = 4;
  bool has_clerkid() const;
  void clear_clerkid() ;
  ::int64_t clerkid() const;
  void set_clerkid(::int64_t value);

  private:
  ::int64_t _internal_clerkid() const;
  void _internal_set_clerkid(::int64_t value);

  public:
  // required int64 cmdIndex = 5;
  bool has_cmdindex() const;
  void clear_cmdindex() ;
  ::int64_t cmdindex() const;
  void set_cmdindex(::int64_t value);

  private:
  ::int64_t _internal_cmdindex() const;
  void _internal_set_cmdindex(::int64_t value);

  public:
  // @@protoc_insertion_point(class_scope:raft_messages.PutAppendRequest)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  ::size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr key_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr op_;
    ::int64_t clerkid_;
    ::int64_t cmdindex_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_raft_5fmessages_2eproto;
};// -------------------------------------------------------------------

class PutAppendResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:raft_messages.PutAppendResponse) */ {
 public:
  inline PutAppendResponse() : PutAppendResponse(nullptr) {}
  ~PutAppendResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR PutAppendResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PutAppendResponse(const PutAppendResponse& from);
  PutAppendResponse(PutAppendResponse&& from) noexcept
    : PutAppendResponse() {
    *this = ::std::move(from);
  }

  inline PutAppendResponse& operator=(const PutAppendResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline PutAppendResponse& operator=(PutAppendResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PutAppendResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const PutAppendResponse* internal_default_instance() {
    return reinterpret_cast<const PutAppendResponse*>(
               &_PutAppendResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(PutAppendResponse& a, PutAppendResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(PutAppendResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PutAppendResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PutAppendResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PutAppendResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PutAppendResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PutAppendResponse& from) {
    PutAppendResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PutAppendResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "raft_messages.PutAppendResponse";
  }
  protected:
  explicit PutAppendResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kErrFieldNumber = 2,
    kWrongLeaderFieldNumber = 1,
  };
  // required string Err = 2;
  bool has_err() const;
  void clear_err() ;
  const std::string& err() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_err(Arg_&& arg, Args_... args);
  std::string* mutable_err();
  PROTOBUF_NODISCARD std::string* release_err();
  void set_allocated_err(std::string* ptr);

  private:
  const std::string& _internal_err() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_err(
      const std::string& value);
  std::string* _internal_mutable_err();

  public:
  // required bool WrongLeader = 1;
  bool has_wrongleader() const;
  void clear_wrongleader() ;
  bool wrongleader() const;
  void set_wrongleader(bool value);

  private:
  bool _internal_wrongleader() const;
  void _internal_set_wrongleader(bool value);

  public:
  // @@protoc_insertion_point(class_scope:raft_messages.PutAppendResponse)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  ::size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr err_;
    bool wrongleader_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_raft_5fmessages_2eproto;
};// -------------------------------------------------------------------

class GetRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:raft_messages.GetRequest) */ {
 public:
  inline GetRequest() : GetRequest(nullptr) {}
  ~GetRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR GetRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetRequest(const GetRequest& from);
  GetRequest(GetRequest&& from) noexcept
    : GetRequest() {
    *this = ::std::move(from);
  }

  inline GetRequest& operator=(const GetRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetRequest& operator=(GetRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetRequest* internal_default_instance() {
    return reinterpret_cast<const GetRequest*>(
               &_GetRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(GetRequest& a, GetRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetRequest& from) {
    GetRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "raft_messages.GetRequest";
  }
  protected:
  explicit GetRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKeyFieldNumber = 1,
    kClerkIDFieldNumber = 2,
    kCmdIndexFieldNumber = 3,
  };
  // required string Key = 1;
  bool has_key() const;
  void clear_key() ;
  const std::string& key() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_key(Arg_&& arg, Args_... args);
  std::string* mutable_key();
  PROTOBUF_NODISCARD std::string* release_key();
  void set_allocated_key(std::string* ptr);

  private:
  const std::string& _internal_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_key(
      const std::string& value);
  std::string* _internal_mutable_key();

  public:
  // required int64 ClerkID = 2;
  bool has_clerkid() const;
  void clear_clerkid() ;
  ::int64_t clerkid() const;
  void set_clerkid(::int64_t value);

  private:
  ::int64_t _internal_clerkid() const;
  void _internal_set_clerkid(::int64_t value);

  public:
  // required int64 CmdIndex = 3;
  bool has_cmdindex() const;
  void clear_cmdindex() ;
  ::int64_t cmdindex() const;
  void set_cmdindex(::int64_t value);

  private:
  ::int64_t _internal_cmdindex() const;
  void _internal_set_cmdindex(::int64_t value);

  public:
  // @@protoc_insertion_point(class_scope:raft_messages.GetRequest)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  ::size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr key_;
    ::int64_t clerkid_;
    ::int64_t cmdindex_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_raft_5fmessages_2eproto;
};// -------------------------------------------------------------------

class GetResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:raft_messages.GetResponse) */ {
 public:
  inline GetResponse() : GetResponse(nullptr) {}
  ~GetResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR GetResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetResponse(const GetResponse& from);
  GetResponse(GetResponse&& from) noexcept
    : GetResponse() {
    *this = ::std::move(from);
  }

  inline GetResponse& operator=(const GetResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetResponse& operator=(GetResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetResponse* internal_default_instance() {
    return reinterpret_cast<const GetResponse*>(
               &_GetResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(GetResponse& a, GetResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetResponse& from) {
    GetResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "raft_messages.GetResponse";
  }
  protected:
  explicit GetResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kErrFieldNumber = 2,
    kValueFieldNumber = 3,
    kWrongLeaderFieldNumber = 1,
  };
  // required string Err = 2;
  bool has_err() const;
  void clear_err() ;
  const std::string& err() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_err(Arg_&& arg, Args_... args);
  std::string* mutable_err();
  PROTOBUF_NODISCARD std::string* release_err();
  void set_allocated_err(std::string* ptr);

  private:
  const std::string& _internal_err() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_err(
      const std::string& value);
  std::string* _internal_mutable_err();

  public:
  // required string Value = 3;
  bool has_value() const;
  void clear_value() ;
  const std::string& value() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_value(Arg_&& arg, Args_... args);
  std::string* mutable_value();
  PROTOBUF_NODISCARD std::string* release_value();
  void set_allocated_value(std::string* ptr);

  private:
  const std::string& _internal_value() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_value(
      const std::string& value);
  std::string* _internal_mutable_value();

  public:
  // required bool WrongLeader = 1;
  bool has_wrongleader() const;
  void clear_wrongleader() ;
  bool wrongleader() const;
  void set_wrongleader(bool value);

  private:
  bool _internal_wrongleader() const;
  void _internal_set_wrongleader(bool value);

  public:
  // @@protoc_insertion_point(class_scope:raft_messages.GetResponse)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  ::size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr err_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_;
    bool wrongleader_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_raft_5fmessages_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// LogEntry

// required int64 index = 1;
inline bool LogEntry::has_index() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void LogEntry::clear_index() {
  _impl_.index_ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::int64_t LogEntry::index() const {
  // @@protoc_insertion_point(field_get:raft_messages.LogEntry.index)
  return _internal_index();
}
inline void LogEntry::set_index(::int64_t value) {
  _internal_set_index(value);
  // @@protoc_insertion_point(field_set:raft_messages.LogEntry.index)
}
inline ::int64_t LogEntry::_internal_index() const {
  return _impl_.index_;
}
inline void LogEntry::_internal_set_index(::int64_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.index_ = value;
}

// required uint64 term = 2;
inline bool LogEntry::has_term() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void LogEntry::clear_term() {
  _impl_.term_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::uint64_t LogEntry::term() const {
  // @@protoc_insertion_point(field_get:raft_messages.LogEntry.term)
  return _internal_term();
}
inline void LogEntry::set_term(::uint64_t value) {
  _internal_set_term(value);
  // @@protoc_insertion_point(field_set:raft_messages.LogEntry.term)
}
inline ::uint64_t LogEntry::_internal_term() const {
  return _impl_.term_;
}
inline void LogEntry::_internal_set_term(::uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.term_ = value;
}

// required int32 command = 3;
inline bool LogEntry::has_command() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void LogEntry::clear_command() {
  _impl_.command_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::int32_t LogEntry::command() const {
  // @@protoc_insertion_point(field_get:raft_messages.LogEntry.command)
  return _internal_command();
}
inline void LogEntry::set_command(::int32_t value) {
  _internal_set_command(value);
  // @@protoc_insertion_point(field_set:raft_messages.LogEntry.command)
}
inline ::int32_t LogEntry::_internal_command() const {
  return _impl_.command_;
}
inline void LogEntry::_internal_set_command(::int32_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.command_ = value;
}

// optional bytes data = 4;
inline bool LogEntry::has_data() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void LogEntry::clear_data() {
  _impl_.data_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& LogEntry::data() const {
  // @@protoc_insertion_point(field_get:raft_messages.LogEntry.data)
  return _internal_data();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void LogEntry::set_data(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.data_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:raft_messages.LogEntry.data)
}
inline std::string* LogEntry::mutable_data() {
  std::string* _s = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:raft_messages.LogEntry.data)
  return _s;
}
inline const std::string& LogEntry::_internal_data() const {
  return _impl_.data_.Get();
}
inline void LogEntry::_internal_set_data(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;


  _impl_.data_.Set(value, GetArenaForAllocation());
}
inline std::string* LogEntry::_internal_mutable_data() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.data_.Mutable( GetArenaForAllocation());
}
inline std::string* LogEntry::release_data() {
  // @@protoc_insertion_point(field_release:raft_messages.LogEntry.data)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.data_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.data_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void LogEntry::set_allocated_data(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.data_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.data_.IsDefault()) {
          _impl_.data_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:raft_messages.LogEntry.data)
}

// -------------------------------------------------------------------

// AppendEntriesRequest

// required string name = 1;
inline bool AppendEntriesRequest::has_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void AppendEntriesRequest::clear_name() {
  _impl_.name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& AppendEntriesRequest::name() const {
  // @@protoc_insertion_point(field_get:raft_messages.AppendEntriesRequest.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void AppendEntriesRequest::set_name(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:raft_messages.AppendEntriesRequest.name)
}
inline std::string* AppendEntriesRequest::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:raft_messages.AppendEntriesRequest.name)
  return _s;
}
inline const std::string& AppendEntriesRequest::_internal_name() const {
  return _impl_.name_.Get();
}
inline void AppendEntriesRequest::_internal_set_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;


  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* AppendEntriesRequest::_internal_mutable_name() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.name_.Mutable( GetArenaForAllocation());
}
inline std::string* AppendEntriesRequest::release_name() {
  // @@protoc_insertion_point(field_release:raft_messages.AppendEntriesRequest.name)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.name_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.name_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void AppendEntriesRequest::set_allocated_name(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.name_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.name_.IsDefault()) {
          _impl_.name_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:raft_messages.AppendEntriesRequest.name)
}

// required uint64 term = 2;
inline bool AppendEntriesRequest::has_term() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void AppendEntriesRequest::clear_term() {
  _impl_.term_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::uint64_t AppendEntriesRequest::term() const {
  // @@protoc_insertion_point(field_get:raft_messages.AppendEntriesRequest.term)
  return _internal_term();
}
inline void AppendEntriesRequest::set_term(::uint64_t value) {
  _internal_set_term(value);
  // @@protoc_insertion_point(field_set:raft_messages.AppendEntriesRequest.term)
}
inline ::uint64_t AppendEntriesRequest::_internal_term() const {
  return _impl_.term_;
}
inline void AppendEntriesRequest::_internal_set_term(::uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.term_ = value;
}

// required int64 prev_log_index = 3;
inline bool AppendEntriesRequest::has_prev_log_index() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void AppendEntriesRequest::clear_prev_log_index() {
  _impl_.prev_log_index_ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::int64_t AppendEntriesRequest::prev_log_index() const {
  // @@protoc_insertion_point(field_get:raft_messages.AppendEntriesRequest.prev_log_index)
  return _internal_prev_log_index();
}
inline void AppendEntriesRequest::set_prev_log_index(::int64_t value) {
  _internal_set_prev_log_index(value);
  // @@protoc_insertion_point(field_set:raft_messages.AppendEntriesRequest.prev_log_index)
}
inline ::int64_t AppendEntriesRequest::_internal_prev_log_index() const {
  return _impl_.prev_log_index_;
}
inline void AppendEntriesRequest::_internal_set_prev_log_index(::int64_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.prev_log_index_ = value;
}

// required uint64 prev_log_term = 4;
inline bool AppendEntriesRequest::has_prev_log_term() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void AppendEntriesRequest::clear_prev_log_term() {
  _impl_.prev_log_term_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::uint64_t AppendEntriesRequest::prev_log_term() const {
  // @@protoc_insertion_point(field_get:raft_messages.AppendEntriesRequest.prev_log_term)
  return _internal_prev_log_term();
}
inline void AppendEntriesRequest::set_prev_log_term(::uint64_t value) {
  _internal_set_prev_log_term(value);
  // @@protoc_insertion_point(field_set:raft_messages.AppendEntriesRequest.prev_log_term)
}
inline ::uint64_t AppendEntriesRequest::_internal_prev_log_term() const {
  return _impl_.prev_log_term_;
}
inline void AppendEntriesRequest::_internal_set_prev_log_term(::uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.prev_log_term_ = value;
}

// required int64 leader_commit = 5;
inline bool AppendEntriesRequest::has_leader_commit() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void AppendEntriesRequest::clear_leader_commit() {
  _impl_.leader_commit_ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::int64_t AppendEntriesRequest::leader_commit() const {
  // @@protoc_insertion_point(field_get:raft_messages.AppendEntriesRequest.leader_commit)
  return _internal_leader_commit();
}
inline void AppendEntriesRequest::set_leader_commit(::int64_t value) {
  _internal_set_leader_commit(value);
  // @@protoc_insertion_point(field_set:raft_messages.AppendEntriesRequest.leader_commit)
}
inline ::int64_t AppendEntriesRequest::_internal_leader_commit() const {
  return _impl_.leader_commit_;
}
inline void AppendEntriesRequest::_internal_set_leader_commit(::int64_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.leader_commit_ = value;
}

// repeated .raft_messages.LogEntry entries = 6;
inline int AppendEntriesRequest::_internal_entries_size() const {
  return _impl_.entries_.size();
}
inline int AppendEntriesRequest::entries_size() const {
  return _internal_entries_size();
}
inline void AppendEntriesRequest::clear_entries() {
  _internal_mutable_entries()->Clear();
}
inline ::raft_messages::LogEntry* AppendEntriesRequest::mutable_entries(int index) {
  // @@protoc_insertion_point(field_mutable:raft_messages.AppendEntriesRequest.entries)
  return _internal_mutable_entries()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::raft_messages::LogEntry >*
AppendEntriesRequest::mutable_entries() {
  // @@protoc_insertion_point(field_mutable_list:raft_messages.AppendEntriesRequest.entries)
  return _internal_mutable_entries();
}
inline const ::raft_messages::LogEntry& AppendEntriesRequest::_internal_entries(int index) const {
  return _internal_entries().Get(index);
}
inline const ::raft_messages::LogEntry& AppendEntriesRequest::entries(int index) const {
  // @@protoc_insertion_point(field_get:raft_messages.AppendEntriesRequest.entries)
  return _internal_entries(index);
}
inline ::raft_messages::LogEntry* AppendEntriesRequest::_internal_add_entries() {
  return _internal_mutable_entries()->Add();
}
inline ::raft_messages::LogEntry* AppendEntriesRequest::add_entries() {
  ::raft_messages::LogEntry* _add = _internal_add_entries();
  // @@protoc_insertion_point(field_add:raft_messages.AppendEntriesRequest.entries)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::raft_messages::LogEntry >&
AppendEntriesRequest::entries() const {
  // @@protoc_insertion_point(field_list:raft_messages.AppendEntriesRequest.entries)
  return _internal_entries();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::raft_messages::LogEntry>&
AppendEntriesRequest::_internal_entries() const {
  return _impl_.entries_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::raft_messages::LogEntry>*
AppendEntriesRequest::_internal_mutable_entries() {
  return &_impl_.entries_;
}

// required uint64 time = 7;
inline bool AppendEntriesRequest::has_time() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline void AppendEntriesRequest::clear_time() {
  _impl_.time_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline ::uint64_t AppendEntriesRequest::time() const {
  // @@protoc_insertion_point(field_get:raft_messages.AppendEntriesRequest.time)
  return _internal_time();
}
inline void AppendEntriesRequest::set_time(::uint64_t value) {
  _internal_set_time(value);
  // @@protoc_insertion_point(field_set:raft_messages.AppendEntriesRequest.time)
}
inline ::uint64_t AppendEntriesRequest::_internal_time() const {
  return _impl_.time_;
}
inline void AppendEntriesRequest::_internal_set_time(::uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.time_ = value;
}

// required uint64 seq = 8;
inline bool AppendEntriesRequest::has_seq() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline void AppendEntriesRequest::clear_seq() {
  _impl_.seq_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline ::uint64_t AppendEntriesRequest::seq() const {
  // @@protoc_insertion_point(field_get:raft_messages.AppendEntriesRequest.seq)
  return _internal_seq();
}
inline void AppendEntriesRequest::set_seq(::uint64_t value) {
  _internal_set_seq(value);
  // @@protoc_insertion_point(field_set:raft_messages.AppendEntriesRequest.seq)
}
inline ::uint64_t AppendEntriesRequest::_internal_seq() const {
  return _impl_.seq_;
}
inline void AppendEntriesRequest::_internal_set_seq(::uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.seq_ = value;
}

// required bool initial = 9;
inline bool AppendEntriesRequest::has_initial() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline void AppendEntriesRequest::clear_initial() {
  _impl_.initial_ = false;
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline bool AppendEntriesRequest::initial() const {
  // @@protoc_insertion_point(field_get:raft_messages.AppendEntriesRequest.initial)
  return _internal_initial();
}
inline void AppendEntriesRequest::set_initial(bool value) {
  _internal_set_initial(value);
  // @@protoc_insertion_point(field_set:raft_messages.AppendEntriesRequest.initial)
}
inline bool AppendEntriesRequest::_internal_initial() const {
  return _impl_.initial_;
}
inline void AppendEntriesRequest::_internal_set_initial(bool value) {
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.initial_ = value;
}

// -------------------------------------------------------------------

// AppendEntriesResponse

// required string name = 1;
inline bool AppendEntriesResponse::has_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void AppendEntriesResponse::clear_name() {
  _impl_.name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& AppendEntriesResponse::name() const {
  // @@protoc_insertion_point(field_get:raft_messages.AppendEntriesResponse.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void AppendEntriesResponse::set_name(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:raft_messages.AppendEntriesResponse.name)
}
inline std::string* AppendEntriesResponse::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:raft_messages.AppendEntriesResponse.name)
  return _s;
}
inline const std::string& AppendEntriesResponse::_internal_name() const {
  return _impl_.name_.Get();
}
inline void AppendEntriesResponse::_internal_set_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;


  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* AppendEntriesResponse::_internal_mutable_name() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.name_.Mutable( GetArenaForAllocation());
}
inline std::string* AppendEntriesResponse::release_name() {
  // @@protoc_insertion_point(field_release:raft_messages.AppendEntriesResponse.name)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.name_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.name_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void AppendEntriesResponse::set_allocated_name(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.name_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.name_.IsDefault()) {
          _impl_.name_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:raft_messages.AppendEntriesResponse.name)
}

// required uint64 term = 2;
inline bool AppendEntriesResponse::has_term() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void AppendEntriesResponse::clear_term() {
  _impl_.term_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::uint64_t AppendEntriesResponse::term() const {
  // @@protoc_insertion_point(field_get:raft_messages.AppendEntriesResponse.term)
  return _internal_term();
}
inline void AppendEntriesResponse::set_term(::uint64_t value) {
  _internal_set_term(value);
  // @@protoc_insertion_point(field_set:raft_messages.AppendEntriesResponse.term)
}
inline ::uint64_t AppendEntriesResponse::_internal_term() const {
  return _impl_.term_;
}
inline void AppendEntriesResponse::_internal_set_term(::uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.term_ = value;
}

// required bool success = 3;
inline bool AppendEntriesResponse::has_success() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline void AppendEntriesResponse::clear_success() {
  _impl_.success_ = false;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline bool AppendEntriesResponse::success() const {
  // @@protoc_insertion_point(field_get:raft_messages.AppendEntriesResponse.success)
  return _internal_success();
}
inline void AppendEntriesResponse::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:raft_messages.AppendEntriesResponse.success)
}
inline bool AppendEntriesResponse::_internal_success() const {
  return _impl_.success_;
}
inline void AppendEntriesResponse::_internal_set_success(bool value) {
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.success_ = value;
}

// required int64 last_log_index = 4;
inline bool AppendEntriesResponse::has_last_log_index() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void AppendEntriesResponse::clear_last_log_index() {
  _impl_.last_log_index_ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::int64_t AppendEntriesResponse::last_log_index() const {
  // @@protoc_insertion_point(field_get:raft_messages.AppendEntriesResponse.last_log_index)
  return _internal_last_log_index();
}
inline void AppendEntriesResponse::set_last_log_index(::int64_t value) {
  _internal_set_last_log_index(value);
  // @@protoc_insertion_point(field_set:raft_messages.AppendEntriesResponse.last_log_index)
}
inline ::int64_t AppendEntriesResponse::_internal_last_log_index() const {
  return _impl_.last_log_index_;
}
inline void AppendEntriesResponse::_internal_set_last_log_index(::int64_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.last_log_index_ = value;
}

// required uint64 last_log_term = 5;
inline bool AppendEntriesResponse::has_last_log_term() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void AppendEntriesResponse::clear_last_log_term() {
  _impl_.last_log_term_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::uint64_t AppendEntriesResponse::last_log_term() const {
  // @@protoc_insertion_point(field_get:raft_messages.AppendEntriesResponse.last_log_term)
  return _internal_last_log_term();
}
inline void AppendEntriesResponse::set_last_log_term(::uint64_t value) {
  _internal_set_last_log_term(value);
  // @@protoc_insertion_point(field_set:raft_messages.AppendEntriesResponse.last_log_term)
}
inline ::uint64_t AppendEntriesResponse::_internal_last_log_term() const {
  return _impl_.last_log_term_;
}
inline void AppendEntriesResponse::_internal_set_last_log_term(::uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.last_log_term_ = value;
}

// required uint64 time = 6;
inline bool AppendEntriesResponse::has_time() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void AppendEntriesResponse::clear_time() {
  _impl_.time_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::uint64_t AppendEntriesResponse::time() const {
  // @@protoc_insertion_point(field_get:raft_messages.AppendEntriesResponse.time)
  return _internal_time();
}
inline void AppendEntriesResponse::set_time(::uint64_t value) {
  _internal_set_time(value);
  // @@protoc_insertion_point(field_set:raft_messages.AppendEntriesResponse.time)
}
inline ::uint64_t AppendEntriesResponse::_internal_time() const {
  return _impl_.time_;
}
inline void AppendEntriesResponse::_internal_set_time(::uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.time_ = value;
}

// required uint64 seq = 7;
inline bool AppendEntriesResponse::has_seq() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline void AppendEntriesResponse::clear_seq() {
  _impl_.seq_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline ::uint64_t AppendEntriesResponse::seq() const {
  // @@protoc_insertion_point(field_get:raft_messages.AppendEntriesResponse.seq)
  return _internal_seq();
}
inline void AppendEntriesResponse::set_seq(::uint64_t value) {
  _internal_set_seq(value);
  // @@protoc_insertion_point(field_set:raft_messages.AppendEntriesResponse.seq)
}
inline ::uint64_t AppendEntriesResponse::_internal_seq() const {
  return _impl_.seq_;
}
inline void AppendEntriesResponse::_internal_set_seq(::uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.seq_ = value;
}

// -------------------------------------------------------------------

// RequestVoteRequest

// required string name = 1;
inline bool RequestVoteRequest::has_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void RequestVoteRequest::clear_name() {
  _impl_.name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& RequestVoteRequest::name() const {
  // @@protoc_insertion_point(field_get:raft_messages.RequestVoteRequest.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RequestVoteRequest::set_name(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:raft_messages.RequestVoteRequest.name)
}
inline std::string* RequestVoteRequest::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:raft_messages.RequestVoteRequest.name)
  return _s;
}
inline const std::string& RequestVoteRequest::_internal_name() const {
  return _impl_.name_.Get();
}
inline void RequestVoteRequest::_internal_set_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;


  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* RequestVoteRequest::_internal_mutable_name() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.name_.Mutable( GetArenaForAllocation());
}
inline std::string* RequestVoteRequest::release_name() {
  // @@protoc_insertion_point(field_release:raft_messages.RequestVoteRequest.name)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.name_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.name_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void RequestVoteRequest::set_allocated_name(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.name_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.name_.IsDefault()) {
          _impl_.name_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:raft_messages.RequestVoteRequest.name)
}

// required uint64 term = 2;
inline bool RequestVoteRequest::has_term() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void RequestVoteRequest::clear_term() {
  _impl_.term_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::uint64_t RequestVoteRequest::term() const {
  // @@protoc_insertion_point(field_get:raft_messages.RequestVoteRequest.term)
  return _internal_term();
}
inline void RequestVoteRequest::set_term(::uint64_t value) {
  _internal_set_term(value);
  // @@protoc_insertion_point(field_set:raft_messages.RequestVoteRequest.term)
}
inline ::uint64_t RequestVoteRequest::_internal_term() const {
  return _impl_.term_;
}
inline void RequestVoteRequest::_internal_set_term(::uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.term_ = value;
}

// required int64 last_log_index = 3;
inline bool RequestVoteRequest::has_last_log_index() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void RequestVoteRequest::clear_last_log_index() {
  _impl_.last_log_index_ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::int64_t RequestVoteRequest::last_log_index() const {
  // @@protoc_insertion_point(field_get:raft_messages.RequestVoteRequest.last_log_index)
  return _internal_last_log_index();
}
inline void RequestVoteRequest::set_last_log_index(::int64_t value) {
  _internal_set_last_log_index(value);
  // @@protoc_insertion_point(field_set:raft_messages.RequestVoteRequest.last_log_index)
}
inline ::int64_t RequestVoteRequest::_internal_last_log_index() const {
  return _impl_.last_log_index_;
}
inline void RequestVoteRequest::_internal_set_last_log_index(::int64_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.last_log_index_ = value;
}

// required uint64 last_log_term = 4;
inline bool RequestVoteRequest::has_last_log_term() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void RequestVoteRequest::clear_last_log_term() {
  _impl_.last_log_term_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::uint64_t RequestVoteRequest::last_log_term() const {
  // @@protoc_insertion_point(field_get:raft_messages.RequestVoteRequest.last_log_term)
  return _internal_last_log_term();
}
inline void RequestVoteRequest::set_last_log_term(::uint64_t value) {
  _internal_set_last_log_term(value);
  // @@protoc_insertion_point(field_set:raft_messages.RequestVoteRequest.last_log_term)
}
inline ::uint64_t RequestVoteRequest::_internal_last_log_term() const {
  return _impl_.last_log_term_;
}
inline void RequestVoteRequest::_internal_set_last_log_term(::uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.last_log_term_ = value;
}

// required uint64 time = 5;
inline bool RequestVoteRequest::has_time() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void RequestVoteRequest::clear_time() {
  _impl_.time_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::uint64_t RequestVoteRequest::time() const {
  // @@protoc_insertion_point(field_get:raft_messages.RequestVoteRequest.time)
  return _internal_time();
}
inline void RequestVoteRequest::set_time(::uint64_t value) {
  _internal_set_time(value);
  // @@protoc_insertion_point(field_set:raft_messages.RequestVoteRequest.time)
}
inline ::uint64_t RequestVoteRequest::_internal_time() const {
  return _impl_.time_;
}
inline void RequestVoteRequest::_internal_set_time(::uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.time_ = value;
}

// required uint64 seq = 6;
inline bool RequestVoteRequest::has_seq() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline void RequestVoteRequest::clear_seq() {
  _impl_.seq_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline ::uint64_t RequestVoteRequest::seq() const {
  // @@protoc_insertion_point(field_get:raft_messages.RequestVoteRequest.seq)
  return _internal_seq();
}
inline void RequestVoteRequest::set_seq(::uint64_t value) {
  _internal_set_seq(value);
  // @@protoc_insertion_point(field_set:raft_messages.RequestVoteRequest.seq)
}
inline ::uint64_t RequestVoteRequest::_internal_seq() const {
  return _impl_.seq_;
}
inline void RequestVoteRequest::_internal_set_seq(::uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.seq_ = value;
}

// required bool initial = 7;
inline bool RequestVoteRequest::has_initial() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline void RequestVoteRequest::clear_initial() {
  _impl_.initial_ = false;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline bool RequestVoteRequest::initial() const {
  // @@protoc_insertion_point(field_get:raft_messages.RequestVoteRequest.initial)
  return _internal_initial();
}
inline void RequestVoteRequest::set_initial(bool value) {
  _internal_set_initial(value);
  // @@protoc_insertion_point(field_set:raft_messages.RequestVoteRequest.initial)
}
inline bool RequestVoteRequest::_internal_initial() const {
  return _impl_.initial_;
}
inline void RequestVoteRequest::_internal_set_initial(bool value) {
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.initial_ = value;
}

// -------------------------------------------------------------------

// RequestVoteResponse

// required string name = 1;
inline bool RequestVoteResponse::has_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void RequestVoteResponse::clear_name() {
  _impl_.name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& RequestVoteResponse::name() const {
  // @@protoc_insertion_point(field_get:raft_messages.RequestVoteResponse.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RequestVoteResponse::set_name(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:raft_messages.RequestVoteResponse.name)
}
inline std::string* RequestVoteResponse::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:raft_messages.RequestVoteResponse.name)
  return _s;
}
inline const std::string& RequestVoteResponse::_internal_name() const {
  return _impl_.name_.Get();
}
inline void RequestVoteResponse::_internal_set_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;


  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* RequestVoteResponse::_internal_mutable_name() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.name_.Mutable( GetArenaForAllocation());
}
inline std::string* RequestVoteResponse::release_name() {
  // @@protoc_insertion_point(field_release:raft_messages.RequestVoteResponse.name)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.name_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.name_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void RequestVoteResponse::set_allocated_name(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.name_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.name_.IsDefault()) {
          _impl_.name_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:raft_messages.RequestVoteResponse.name)
}

// required uint64 term = 2;
inline bool RequestVoteResponse::has_term() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void RequestVoteResponse::clear_term() {
  _impl_.term_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::uint64_t RequestVoteResponse::term() const {
  // @@protoc_insertion_point(field_get:raft_messages.RequestVoteResponse.term)
  return _internal_term();
}
inline void RequestVoteResponse::set_term(::uint64_t value) {
  _internal_set_term(value);
  // @@protoc_insertion_point(field_set:raft_messages.RequestVoteResponse.term)
}
inline ::uint64_t RequestVoteResponse::_internal_term() const {
  return _impl_.term_;
}
inline void RequestVoteResponse::_internal_set_term(::uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.term_ = value;
}

// required bool vote_granted = 3;
inline bool RequestVoteResponse::has_vote_granted() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void RequestVoteResponse::clear_vote_granted() {
  _impl_.vote_granted_ = false;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline bool RequestVoteResponse::vote_granted() const {
  // @@protoc_insertion_point(field_get:raft_messages.RequestVoteResponse.vote_granted)
  return _internal_vote_granted();
}
inline void RequestVoteResponse::set_vote_granted(bool value) {
  _internal_set_vote_granted(value);
  // @@protoc_insertion_point(field_set:raft_messages.RequestVoteResponse.vote_granted)
}
inline bool RequestVoteResponse::_internal_vote_granted() const {
  return _impl_.vote_granted_;
}
inline void RequestVoteResponse::_internal_set_vote_granted(bool value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.vote_granted_ = value;
}

// required uint64 time = 4;
inline bool RequestVoteResponse::has_time() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void RequestVoteResponse::clear_time() {
  _impl_.time_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::uint64_t RequestVoteResponse::time() const {
  // @@protoc_insertion_point(field_get:raft_messages.RequestVoteResponse.time)
  return _internal_time();
}
inline void RequestVoteResponse::set_time(::uint64_t value) {
  _internal_set_time(value);
  // @@protoc_insertion_point(field_set:raft_messages.RequestVoteResponse.time)
}
inline ::uint64_t RequestVoteResponse::_internal_time() const {
  return _impl_.time_;
}
inline void RequestVoteResponse::_internal_set_time(::uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.time_ = value;
}

// required uint64 seq = 5;
inline bool RequestVoteResponse::has_seq() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void RequestVoteResponse::clear_seq() {
  _impl_.seq_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::uint64_t RequestVoteResponse::seq() const {
  // @@protoc_insertion_point(field_get:raft_messages.RequestVoteResponse.seq)
  return _internal_seq();
}
inline void RequestVoteResponse::set_seq(::uint64_t value) {
  _internal_set_seq(value);
  // @@protoc_insertion_point(field_set:raft_messages.RequestVoteResponse.seq)
}
inline ::uint64_t RequestVoteResponse::_internal_seq() const {
  return _impl_.seq_;
}
inline void RequestVoteResponse::_internal_set_seq(::uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.seq_ = value;
}

// -------------------------------------------------------------------

// InstallSnapshotRequest

// required uint64 term = 1;
inline bool InstallSnapshotRequest::has_term() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void InstallSnapshotRequest::clear_term() {
  _impl_.term_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::uint64_t InstallSnapshotRequest::term() const {
  // @@protoc_insertion_point(field_get:raft_messages.InstallSnapshotRequest.term)
  return _internal_term();
}
inline void InstallSnapshotRequest::set_term(::uint64_t value) {
  _internal_set_term(value);
  // @@protoc_insertion_point(field_set:raft_messages.InstallSnapshotRequest.term)
}
inline ::uint64_t InstallSnapshotRequest::_internal_term() const {
  return _impl_.term_;
}
inline void InstallSnapshotRequest::_internal_set_term(::uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.term_ = value;
}

// required string name = 2;
inline bool InstallSnapshotRequest::has_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void InstallSnapshotRequest::clear_name() {
  _impl_.name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& InstallSnapshotRequest::name() const {
  // @@protoc_insertion_point(field_get:raft_messages.InstallSnapshotRequest.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void InstallSnapshotRequest::set_name(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:raft_messages.InstallSnapshotRequest.name)
}
inline std::string* InstallSnapshotRequest::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:raft_messages.InstallSnapshotRequest.name)
  return _s;
}
inline const std::string& InstallSnapshotRequest::_internal_name() const {
  return _impl_.name_.Get();
}
inline void InstallSnapshotRequest::_internal_set_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;


  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* InstallSnapshotRequest::_internal_mutable_name() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.name_.Mutable( GetArenaForAllocation());
}
inline std::string* InstallSnapshotRequest::release_name() {
  // @@protoc_insertion_point(field_release:raft_messages.InstallSnapshotRequest.name)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.name_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.name_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void InstallSnapshotRequest::set_allocated_name(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.name_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.name_.IsDefault()) {
          _impl_.name_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:raft_messages.InstallSnapshotRequest.name)
}

// required int64 last_included_index = 3;
inline bool InstallSnapshotRequest::has_last_included_index() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void InstallSnapshotRequest::clear_last_included_index() {
  _impl_.last_included_index_ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::int64_t InstallSnapshotRequest::last_included_index() const {
  // @@protoc_insertion_point(field_get:raft_messages.InstallSnapshotRequest.last_included_index)
  return _internal_last_included_index();
}
inline void InstallSnapshotRequest::set_last_included_index(::int64_t value) {
  _internal_set_last_included_index(value);
  // @@protoc_insertion_point(field_set:raft_messages.InstallSnapshotRequest.last_included_index)
}
inline ::int64_t InstallSnapshotRequest::_internal_last_included_index() const {
  return _impl_.last_included_index_;
}
inline void InstallSnapshotRequest::_internal_set_last_included_index(::int64_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.last_included_index_ = value;
}

// required int64 last_included_term = 4;
inline bool InstallSnapshotRequest::has_last_included_term() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void InstallSnapshotRequest::clear_last_included_term() {
  _impl_.last_included_term_ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::int64_t InstallSnapshotRequest::last_included_term() const {
  // @@protoc_insertion_point(field_get:raft_messages.InstallSnapshotRequest.last_included_term)
  return _internal_last_included_term();
}
inline void InstallSnapshotRequest::set_last_included_term(::int64_t value) {
  _internal_set_last_included_term(value);
  // @@protoc_insertion_point(field_set:raft_messages.InstallSnapshotRequest.last_included_term)
}
inline ::int64_t InstallSnapshotRequest::_internal_last_included_term() const {
  return _impl_.last_included_term_;
}
inline void InstallSnapshotRequest::_internal_set_last_included_term(::int64_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.last_included_term_ = value;
}

// required bytes data = 6;
inline bool InstallSnapshotRequest::has_data() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void InstallSnapshotRequest::clear_data() {
  _impl_.data_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& InstallSnapshotRequest::data() const {
  // @@protoc_insertion_point(field_get:raft_messages.InstallSnapshotRequest.data)
  return _internal_data();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void InstallSnapshotRequest::set_data(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.data_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:raft_messages.InstallSnapshotRequest.data)
}
inline std::string* InstallSnapshotRequest::mutable_data() {
  std::string* _s = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:raft_messages.InstallSnapshotRequest.data)
  return _s;
}
inline const std::string& InstallSnapshotRequest::_internal_data() const {
  return _impl_.data_.Get();
}
inline void InstallSnapshotRequest::_internal_set_data(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;


  _impl_.data_.Set(value, GetArenaForAllocation());
}
inline std::string* InstallSnapshotRequest::_internal_mutable_data() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.data_.Mutable( GetArenaForAllocation());
}
inline std::string* InstallSnapshotRequest::release_data() {
  // @@protoc_insertion_point(field_release:raft_messages.InstallSnapshotRequest.data)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.data_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.data_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void InstallSnapshotRequest::set_allocated_data(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.data_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.data_.IsDefault()) {
          _impl_.data_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:raft_messages.InstallSnapshotRequest.data)
}

// required uint64 time = 7;
inline bool InstallSnapshotRequest::has_time() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline void InstallSnapshotRequest::clear_time() {
  _impl_.time_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline ::uint64_t InstallSnapshotRequest::time() const {
  // @@protoc_insertion_point(field_get:raft_messages.InstallSnapshotRequest.time)
  return _internal_time();
}
inline void InstallSnapshotRequest::set_time(::uint64_t value) {
  _internal_set_time(value);
  // @@protoc_insertion_point(field_set:raft_messages.InstallSnapshotRequest.time)
}
inline ::uint64_t InstallSnapshotRequest::_internal_time() const {
  return _impl_.time_;
}
inline void InstallSnapshotRequest::_internal_set_time(::uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.time_ = value;
}

// required uint64 seq = 8;
inline bool InstallSnapshotRequest::has_seq() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline void InstallSnapshotRequest::clear_seq() {
  _impl_.seq_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline ::uint64_t InstallSnapshotRequest::seq() const {
  // @@protoc_insertion_point(field_get:raft_messages.InstallSnapshotRequest.seq)
  return _internal_seq();
}
inline void InstallSnapshotRequest::set_seq(::uint64_t value) {
  _internal_set_seq(value);
  // @@protoc_insertion_point(field_set:raft_messages.InstallSnapshotRequest.seq)
}
inline ::uint64_t InstallSnapshotRequest::_internal_seq() const {
  return _impl_.seq_;
}
inline void InstallSnapshotRequest::_internal_set_seq(::uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.seq_ = value;
}

// required bool initial = 9;
inline bool InstallSnapshotRequest::has_initial() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline void InstallSnapshotRequest::clear_initial() {
  _impl_.initial_ = false;
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline bool InstallSnapshotRequest::initial() const {
  // @@protoc_insertion_point(field_get:raft_messages.InstallSnapshotRequest.initial)
  return _internal_initial();
}
inline void InstallSnapshotRequest::set_initial(bool value) {
  _internal_set_initial(value);
  // @@protoc_insertion_point(field_set:raft_messages.InstallSnapshotRequest.initial)
}
inline bool InstallSnapshotRequest::_internal_initial() const {
  return _impl_.initial_;
}
inline void InstallSnapshotRequest::_internal_set_initial(bool value) {
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.initial_ = value;
}

// -------------------------------------------------------------------

// InstallSnapshotResponse

// required uint64 term = 1;
inline bool InstallSnapshotResponse::has_term() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void InstallSnapshotResponse::clear_term() {
  _impl_.term_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::uint64_t InstallSnapshotResponse::term() const {
  // @@protoc_insertion_point(field_get:raft_messages.InstallSnapshotResponse.term)
  return _internal_term();
}
inline void InstallSnapshotResponse::set_term(::uint64_t value) {
  _internal_set_term(value);
  // @@protoc_insertion_point(field_set:raft_messages.InstallSnapshotResponse.term)
}
inline ::uint64_t InstallSnapshotResponse::_internal_term() const {
  return _impl_.term_;
}
inline void InstallSnapshotResponse::_internal_set_term(::uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.term_ = value;
}

// required string name = 2;
inline bool InstallSnapshotResponse::has_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void InstallSnapshotResponse::clear_name() {
  _impl_.name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& InstallSnapshotResponse::name() const {
  // @@protoc_insertion_point(field_get:raft_messages.InstallSnapshotResponse.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void InstallSnapshotResponse::set_name(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:raft_messages.InstallSnapshotResponse.name)
}
inline std::string* InstallSnapshotResponse::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:raft_messages.InstallSnapshotResponse.name)
  return _s;
}
inline const std::string& InstallSnapshotResponse::_internal_name() const {
  return _impl_.name_.Get();
}
inline void InstallSnapshotResponse::_internal_set_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;


  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* InstallSnapshotResponse::_internal_mutable_name() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.name_.Mutable( GetArenaForAllocation());
}
inline std::string* InstallSnapshotResponse::release_name() {
  // @@protoc_insertion_point(field_release:raft_messages.InstallSnapshotResponse.name)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.name_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.name_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void InstallSnapshotResponse::set_allocated_name(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.name_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.name_.IsDefault()) {
          _impl_.name_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:raft_messages.InstallSnapshotResponse.name)
}

// required int64 last_included_index = 3;
inline bool InstallSnapshotResponse::has_last_included_index() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void InstallSnapshotResponse::clear_last_included_index() {
  _impl_.last_included_index_ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::int64_t InstallSnapshotResponse::last_included_index() const {
  // @@protoc_insertion_point(field_get:raft_messages.InstallSnapshotResponse.last_included_index)
  return _internal_last_included_index();
}
inline void InstallSnapshotResponse::set_last_included_index(::int64_t value) {
  _internal_set_last_included_index(value);
  // @@protoc_insertion_point(field_set:raft_messages.InstallSnapshotResponse.last_included_index)
}
inline ::int64_t InstallSnapshotResponse::_internal_last_included_index() const {
  return _impl_.last_included_index_;
}
inline void InstallSnapshotResponse::_internal_set_last_included_index(::int64_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.last_included_index_ = value;
}

// required int64 last_included_term = 4;
inline bool InstallSnapshotResponse::has_last_included_term() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void InstallSnapshotResponse::clear_last_included_term() {
  _impl_.last_included_term_ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::int64_t InstallSnapshotResponse::last_included_term() const {
  // @@protoc_insertion_point(field_get:raft_messages.InstallSnapshotResponse.last_included_term)
  return _internal_last_included_term();
}
inline void InstallSnapshotResponse::set_last_included_term(::int64_t value) {
  _internal_set_last_included_term(value);
  // @@protoc_insertion_point(field_set:raft_messages.InstallSnapshotResponse.last_included_term)
}
inline ::int64_t InstallSnapshotResponse::_internal_last_included_term() const {
  return _impl_.last_included_term_;
}
inline void InstallSnapshotResponse::_internal_set_last_included_term(::int64_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.last_included_term_ = value;
}

// required bool success = 5;
inline bool InstallSnapshotResponse::has_success() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline void InstallSnapshotResponse::clear_success() {
  _impl_.success_ = false;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline bool InstallSnapshotResponse::success() const {
  // @@protoc_insertion_point(field_get:raft_messages.InstallSnapshotResponse.success)
  return _internal_success();
}
inline void InstallSnapshotResponse::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:raft_messages.InstallSnapshotResponse.success)
}
inline bool InstallSnapshotResponse::_internal_success() const {
  return _impl_.success_;
}
inline void InstallSnapshotResponse::_internal_set_success(bool value) {
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.success_ = value;
}

// required uint64 time = 6;
inline bool InstallSnapshotResponse::has_time() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void InstallSnapshotResponse::clear_time() {
  _impl_.time_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::uint64_t InstallSnapshotResponse::time() const {
  // @@protoc_insertion_point(field_get:raft_messages.InstallSnapshotResponse.time)
  return _internal_time();
}
inline void InstallSnapshotResponse::set_time(::uint64_t value) {
  _internal_set_time(value);
  // @@protoc_insertion_point(field_set:raft_messages.InstallSnapshotResponse.time)
}
inline ::uint64_t InstallSnapshotResponse::_internal_time() const {
  return _impl_.time_;
}
inline void InstallSnapshotResponse::_internal_set_time(::uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.time_ = value;
}

// required uint64 seq = 7;
inline bool InstallSnapshotResponse::has_seq() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline void InstallSnapshotResponse::clear_seq() {
  _impl_.seq_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline ::uint64_t InstallSnapshotResponse::seq() const {
  // @@protoc_insertion_point(field_get:raft_messages.InstallSnapshotResponse.seq)
  return _internal_seq();
}
inline void InstallSnapshotResponse::set_seq(::uint64_t value) {
  _internal_set_seq(value);
  // @@protoc_insertion_point(field_set:raft_messages.InstallSnapshotResponse.seq)
}
inline ::uint64_t InstallSnapshotResponse::_internal_seq() const {
  return _impl_.seq_;
}
inline void InstallSnapshotResponse::_internal_set_seq(::uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.seq_ = value;
}

// -------------------------------------------------------------------

// ConfRecord

// required string peers = 1;
inline bool ConfRecord::has_peers() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void ConfRecord::clear_peers() {
  _impl_.peers_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ConfRecord::peers() const {
  // @@protoc_insertion_point(field_get:raft_messages.ConfRecord.peers)
  return _internal_peers();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ConfRecord::set_peers(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.peers_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:raft_messages.ConfRecord.peers)
}
inline std::string* ConfRecord::mutable_peers() {
  std::string* _s = _internal_mutable_peers();
  // @@protoc_insertion_point(field_mutable:raft_messages.ConfRecord.peers)
  return _s;
}
inline const std::string& ConfRecord::_internal_peers() const {
  return _impl_.peers_.Get();
}
inline void ConfRecord::_internal_set_peers(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;


  _impl_.peers_.Set(value, GetArenaForAllocation());
}
inline std::string* ConfRecord::_internal_mutable_peers() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.peers_.Mutable( GetArenaForAllocation());
}
inline std::string* ConfRecord::release_peers() {
  // @@protoc_insertion_point(field_release:raft_messages.ConfRecord.peers)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.peers_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.peers_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void ConfRecord::set_allocated_peers(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.peers_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.peers_.IsDefault()) {
          _impl_.peers_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:raft_messages.ConfRecord.peers)
}

// required int64 index = 2;
inline bool ConfRecord::has_index() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void ConfRecord::clear_index() {
  _impl_.index_ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::int64_t ConfRecord::index() const {
  // @@protoc_insertion_point(field_get:raft_messages.ConfRecord.index)
  return _internal_index();
}
inline void ConfRecord::set_index(::int64_t value) {
  _internal_set_index(value);
  // @@protoc_insertion_point(field_set:raft_messages.ConfRecord.index)
}
inline ::int64_t ConfRecord::_internal_index() const {
  return _impl_.index_;
}
inline void ConfRecord::_internal_set_index(::int64_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.index_ = value;
}

// required int64 index2 = 3;
inline bool ConfRecord::has_index2() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void ConfRecord::clear_index2() {
  _impl_.index2_ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::int64_t ConfRecord::index2() const {
  // @@protoc_insertion_point(field_get:raft_messages.ConfRecord.index2)
  return _internal_index2();
}
inline void ConfRecord::set_index2(::int64_t value) {
  _internal_set_index2(value);
  // @@protoc_insertion_point(field_set:raft_messages.ConfRecord.index2)
}
inline ::int64_t ConfRecord::_internal_index2() const {
  return _impl_.index2_;
}
inline void ConfRecord::_internal_set_index2(::int64_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.index2_ = value;
}

// required int64 state = 4;
inline bool ConfRecord::has_state() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void ConfRecord::clear_state() {
  _impl_.state_ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::int64_t ConfRecord::state() const {
  // @@protoc_insertion_point(field_get:raft_messages.ConfRecord.state)
  return _internal_state();
}
inline void ConfRecord::set_state(::int64_t value) {
  _internal_set_state(value);
  // @@protoc_insertion_point(field_set:raft_messages.ConfRecord.state)
}
inline ::int64_t ConfRecord::_internal_state() const {
  return _impl_.state_;
}
inline void ConfRecord::_internal_set_state(::int64_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.state_ = value;
}

// -------------------------------------------------------------------

// PersistRecord

// required uint64 term = 1;
inline bool PersistRecord::has_term() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void PersistRecord::clear_term() {
  _impl_.term_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::uint64_t PersistRecord::term() const {
  // @@protoc_insertion_point(field_get:raft_messages.PersistRecord.term)
  return _internal_term();
}
inline void PersistRecord::set_term(::uint64_t value) {
  _internal_set_term(value);
  // @@protoc_insertion_point(field_set:raft_messages.PersistRecord.term)
}
inline ::uint64_t PersistRecord::_internal_term() const {
  return _impl_.term_;
}
inline void PersistRecord::_internal_set_term(::uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.term_ = value;
}

// required string name = 2;
inline bool PersistRecord::has_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void PersistRecord::clear_name() {
  _impl_.name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& PersistRecord::name() const {
  // @@protoc_insertion_point(field_get:raft_messages.PersistRecord.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PersistRecord::set_name(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:raft_messages.PersistRecord.name)
}
inline std::string* PersistRecord::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:raft_messages.PersistRecord.name)
  return _s;
}
inline const std::string& PersistRecord::_internal_name() const {
  return _impl_.name_.Get();
}
inline void PersistRecord::_internal_set_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;


  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* PersistRecord::_internal_mutable_name() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.name_.Mutable( GetArenaForAllocation());
}
inline std::string* PersistRecord::release_name() {
  // @@protoc_insertion_point(field_release:raft_messages.PersistRecord.name)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.name_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.name_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void PersistRecord::set_allocated_name(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.name_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.name_.IsDefault()) {
          _impl_.name_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:raft_messages.PersistRecord.name)
}

// required string vote_for = 3;
inline bool PersistRecord::has_vote_for() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void PersistRecord::clear_vote_for() {
  _impl_.vote_for_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& PersistRecord::vote_for() const {
  // @@protoc_insertion_point(field_get:raft_messages.PersistRecord.vote_for)
  return _internal_vote_for();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PersistRecord::set_vote_for(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.vote_for_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:raft_messages.PersistRecord.vote_for)
}
inline std::string* PersistRecord::mutable_vote_for() {
  std::string* _s = _internal_mutable_vote_for();
  // @@protoc_insertion_point(field_mutable:raft_messages.PersistRecord.vote_for)
  return _s;
}
inline const std::string& PersistRecord::_internal_vote_for() const {
  return _impl_.vote_for_.Get();
}
inline void PersistRecord::_internal_set_vote_for(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;


  _impl_.vote_for_.Set(value, GetArenaForAllocation());
}
inline std::string* PersistRecord::_internal_mutable_vote_for() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.vote_for_.Mutable( GetArenaForAllocation());
}
inline std::string* PersistRecord::release_vote_for() {
  // @@protoc_insertion_point(field_release:raft_messages.PersistRecord.vote_for)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.vote_for_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.vote_for_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void PersistRecord::set_allocated_vote_for(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.vote_for_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.vote_for_.IsDefault()) {
          _impl_.vote_for_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:raft_messages.PersistRecord.vote_for)
}

// repeated .raft_messages.LogEntry entries = 4;
inline int PersistRecord::_internal_entries_size() const {
  return _impl_.entries_.size();
}
inline int PersistRecord::entries_size() const {
  return _internal_entries_size();
}
inline void PersistRecord::clear_entries() {
  _internal_mutable_entries()->Clear();
}
inline ::raft_messages::LogEntry* PersistRecord::mutable_entries(int index) {
  // @@protoc_insertion_point(field_mutable:raft_messages.PersistRecord.entries)
  return _internal_mutable_entries()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::raft_messages::LogEntry >*
PersistRecord::mutable_entries() {
  // @@protoc_insertion_point(field_mutable_list:raft_messages.PersistRecord.entries)
  return _internal_mutable_entries();
}
inline const ::raft_messages::LogEntry& PersistRecord::_internal_entries(int index) const {
  return _internal_entries().Get(index);
}
inline const ::raft_messages::LogEntry& PersistRecord::entries(int index) const {
  // @@protoc_insertion_point(field_get:raft_messages.PersistRecord.entries)
  return _internal_entries(index);
}
inline ::raft_messages::LogEntry* PersistRecord::_internal_add_entries() {
  return _internal_mutable_entries()->Add();
}
inline ::raft_messages::LogEntry* PersistRecord::add_entries() {
  ::raft_messages::LogEntry* _add = _internal_add_entries();
  // @@protoc_insertion_point(field_add:raft_messages.PersistRecord.entries)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::raft_messages::LogEntry >&
PersistRecord::entries() const {
  // @@protoc_insertion_point(field_list:raft_messages.PersistRecord.entries)
  return _internal_entries();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::raft_messages::LogEntry>&
PersistRecord::_internal_entries() const {
  return _impl_.entries_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::raft_messages::LogEntry>*
PersistRecord::_internal_mutable_entries() {
  return &_impl_.entries_;
}

// optional .raft_messages.ConfRecord conf_record = 5;
inline bool PersistRecord::has_conf_record() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.conf_record_ != nullptr);
  return value;
}
inline void PersistRecord::clear_conf_record() {
  if (_impl_.conf_record_ != nullptr) _impl_.conf_record_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::raft_messages::ConfRecord& PersistRecord::_internal_conf_record() const {
  const ::raft_messages::ConfRecord* p = _impl_.conf_record_;
  return p != nullptr ? *p : reinterpret_cast<const ::raft_messages::ConfRecord&>(
      ::raft_messages::_ConfRecord_default_instance_);
}
inline const ::raft_messages::ConfRecord& PersistRecord::conf_record() const {
  // @@protoc_insertion_point(field_get:raft_messages.PersistRecord.conf_record)
  return _internal_conf_record();
}
inline void PersistRecord::unsafe_arena_set_allocated_conf_record(
    ::raft_messages::ConfRecord* conf_record) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.conf_record_);
  }
  _impl_.conf_record_ = conf_record;
  if (conf_record) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:raft_messages.PersistRecord.conf_record)
}
inline ::raft_messages::ConfRecord* PersistRecord::release_conf_record() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::raft_messages::ConfRecord* temp = _impl_.conf_record_;
  _impl_.conf_record_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::raft_messages::ConfRecord* PersistRecord::unsafe_arena_release_conf_record() {
  // @@protoc_insertion_point(field_release:raft_messages.PersistRecord.conf_record)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::raft_messages::ConfRecord* temp = _impl_.conf_record_;
  _impl_.conf_record_ = nullptr;
  return temp;
}
inline ::raft_messages::ConfRecord* PersistRecord::_internal_mutable_conf_record() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.conf_record_ == nullptr) {
    auto* p = CreateMaybeMessage<::raft_messages::ConfRecord>(GetArenaForAllocation());
    _impl_.conf_record_ = p;
  }
  return _impl_.conf_record_;
}
inline ::raft_messages::ConfRecord* PersistRecord::mutable_conf_record() {
  ::raft_messages::ConfRecord* _msg = _internal_mutable_conf_record();
  // @@protoc_insertion_point(field_mutable:raft_messages.PersistRecord.conf_record)
  return _msg;
}
inline void PersistRecord::set_allocated_conf_record(::raft_messages::ConfRecord* conf_record) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.conf_record_;
  }
  if (conf_record) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(conf_record);
    if (message_arena != submessage_arena) {
      conf_record = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, conf_record, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.conf_record_ = conf_record;
  // @@protoc_insertion_point(field_set_allocated:raft_messages.PersistRecord.conf_record)
}

// required uint64 last_seq = 6;
inline bool PersistRecord::has_last_seq() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void PersistRecord::clear_last_seq() {
  _impl_.last_seq_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::uint64_t PersistRecord::last_seq() const {
  // @@protoc_insertion_point(field_get:raft_messages.PersistRecord.last_seq)
  return _internal_last_seq();
}
inline void PersistRecord::set_last_seq(::uint64_t value) {
  _internal_set_last_seq(value);
  // @@protoc_insertion_point(field_set:raft_messages.PersistRecord.last_seq)
}
inline ::uint64_t PersistRecord::_internal_last_seq() const {
  return _impl_.last_seq_;
}
inline void PersistRecord::_internal_set_last_seq(::uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.last_seq_ = value;
}

// -------------------------------------------------------------------

// PutAppendRequest

// required string key = 1;
inline bool PutAppendRequest::has_key() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void PutAppendRequest::clear_key() {
  _impl_.key_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& PutAppendRequest::key() const {
  // @@protoc_insertion_point(field_get:raft_messages.PutAppendRequest.key)
  return _internal_key();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PutAppendRequest::set_key(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.key_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:raft_messages.PutAppendRequest.key)
}
inline std::string* PutAppendRequest::mutable_key() {
  std::string* _s = _internal_mutable_key();
  // @@protoc_insertion_point(field_mutable:raft_messages.PutAppendRequest.key)
  return _s;
}
inline const std::string& PutAppendRequest::_internal_key() const {
  return _impl_.key_.Get();
}
inline void PutAppendRequest::_internal_set_key(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;


  _impl_.key_.Set(value, GetArenaForAllocation());
}
inline std::string* PutAppendRequest::_internal_mutable_key() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.key_.Mutable( GetArenaForAllocation());
}
inline std::string* PutAppendRequest::release_key() {
  // @@protoc_insertion_point(field_release:raft_messages.PutAppendRequest.key)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.key_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.key_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void PutAppendRequest::set_allocated_key(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.key_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.key_.IsDefault()) {
          _impl_.key_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:raft_messages.PutAppendRequest.key)
}

// required string value = 2;
inline bool PutAppendRequest::has_value() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void PutAppendRequest::clear_value() {
  _impl_.value_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& PutAppendRequest::value() const {
  // @@protoc_insertion_point(field_get:raft_messages.PutAppendRequest.value)
  return _internal_value();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PutAppendRequest::set_value(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.value_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:raft_messages.PutAppendRequest.value)
}
inline std::string* PutAppendRequest::mutable_value() {
  std::string* _s = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:raft_messages.PutAppendRequest.value)
  return _s;
}
inline const std::string& PutAppendRequest::_internal_value() const {
  return _impl_.value_.Get();
}
inline void PutAppendRequest::_internal_set_value(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;


  _impl_.value_.Set(value, GetArenaForAllocation());
}
inline std::string* PutAppendRequest::_internal_mutable_value() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.value_.Mutable( GetArenaForAllocation());
}
inline std::string* PutAppendRequest::release_value() {
  // @@protoc_insertion_point(field_release:raft_messages.PutAppendRequest.value)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.value_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.value_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void PutAppendRequest::set_allocated_value(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.value_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.value_.IsDefault()) {
          _impl_.value_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:raft_messages.PutAppendRequest.value)
}

// required string op = 3;
inline bool PutAppendRequest::has_op() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void PutAppendRequest::clear_op() {
  _impl_.op_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& PutAppendRequest::op() const {
  // @@protoc_insertion_point(field_get:raft_messages.PutAppendRequest.op)
  return _internal_op();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PutAppendRequest::set_op(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.op_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:raft_messages.PutAppendRequest.op)
}
inline std::string* PutAppendRequest::mutable_op() {
  std::string* _s = _internal_mutable_op();
  // @@protoc_insertion_point(field_mutable:raft_messages.PutAppendRequest.op)
  return _s;
}
inline const std::string& PutAppendRequest::_internal_op() const {
  return _impl_.op_.Get();
}
inline void PutAppendRequest::_internal_set_op(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000004u;


  _impl_.op_.Set(value, GetArenaForAllocation());
}
inline std::string* PutAppendRequest::_internal_mutable_op() {
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.op_.Mutable( GetArenaForAllocation());
}
inline std::string* PutAppendRequest::release_op() {
  // @@protoc_insertion_point(field_release:raft_messages.PutAppendRequest.op)
  if ((_impl_._has_bits_[0] & 0x00000004u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* released = _impl_.op_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.op_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void PutAppendRequest::set_allocated_op(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.op_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.op_.IsDefault()) {
          _impl_.op_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:raft_messages.PutAppendRequest.op)
}

// required int64 ClerkID = 4;
inline bool PutAppendRequest::has_clerkid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void PutAppendRequest::clear_clerkid() {
  _impl_.clerkid_ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::int64_t PutAppendRequest::clerkid() const {
  // @@protoc_insertion_point(field_get:raft_messages.PutAppendRequest.ClerkID)
  return _internal_clerkid();
}
inline void PutAppendRequest::set_clerkid(::int64_t value) {
  _internal_set_clerkid(value);
  // @@protoc_insertion_point(field_set:raft_messages.PutAppendRequest.ClerkID)
}
inline ::int64_t PutAppendRequest::_internal_clerkid() const {
  return _impl_.clerkid_;
}
inline void PutAppendRequest::_internal_set_clerkid(::int64_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.clerkid_ = value;
}

// required int64 cmdIndex = 5;
inline bool PutAppendRequest::has_cmdindex() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void PutAppendRequest::clear_cmdindex() {
  _impl_.cmdindex_ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::int64_t PutAppendRequest::cmdindex() const {
  // @@protoc_insertion_point(field_get:raft_messages.PutAppendRequest.cmdIndex)
  return _internal_cmdindex();
}
inline void PutAppendRequest::set_cmdindex(::int64_t value) {
  _internal_set_cmdindex(value);
  // @@protoc_insertion_point(field_set:raft_messages.PutAppendRequest.cmdIndex)
}
inline ::int64_t PutAppendRequest::_internal_cmdindex() const {
  return _impl_.cmdindex_;
}
inline void PutAppendRequest::_internal_set_cmdindex(::int64_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.cmdindex_ = value;
}

// -------------------------------------------------------------------

// PutAppendResponse

// required bool WrongLeader = 1;
inline bool PutAppendResponse::has_wrongleader() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void PutAppendResponse::clear_wrongleader() {
  _impl_.wrongleader_ = false;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline bool PutAppendResponse::wrongleader() const {
  // @@protoc_insertion_point(field_get:raft_messages.PutAppendResponse.WrongLeader)
  return _internal_wrongleader();
}
inline void PutAppendResponse::set_wrongleader(bool value) {
  _internal_set_wrongleader(value);
  // @@protoc_insertion_point(field_set:raft_messages.PutAppendResponse.WrongLeader)
}
inline bool PutAppendResponse::_internal_wrongleader() const {
  return _impl_.wrongleader_;
}
inline void PutAppendResponse::_internal_set_wrongleader(bool value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.wrongleader_ = value;
}

// required string Err = 2;
inline bool PutAppendResponse::has_err() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void PutAppendResponse::clear_err() {
  _impl_.err_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& PutAppendResponse::err() const {
  // @@protoc_insertion_point(field_get:raft_messages.PutAppendResponse.Err)
  return _internal_err();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PutAppendResponse::set_err(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.err_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:raft_messages.PutAppendResponse.Err)
}
inline std::string* PutAppendResponse::mutable_err() {
  std::string* _s = _internal_mutable_err();
  // @@protoc_insertion_point(field_mutable:raft_messages.PutAppendResponse.Err)
  return _s;
}
inline const std::string& PutAppendResponse::_internal_err() const {
  return _impl_.err_.Get();
}
inline void PutAppendResponse::_internal_set_err(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;


  _impl_.err_.Set(value, GetArenaForAllocation());
}
inline std::string* PutAppendResponse::_internal_mutable_err() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.err_.Mutable( GetArenaForAllocation());
}
inline std::string* PutAppendResponse::release_err() {
  // @@protoc_insertion_point(field_release:raft_messages.PutAppendResponse.Err)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.err_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.err_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void PutAppendResponse::set_allocated_err(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.err_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.err_.IsDefault()) {
          _impl_.err_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:raft_messages.PutAppendResponse.Err)
}

// -------------------------------------------------------------------

// GetRequest

// required string Key = 1;
inline bool GetRequest::has_key() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void GetRequest::clear_key() {
  _impl_.key_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& GetRequest::key() const {
  // @@protoc_insertion_point(field_get:raft_messages.GetRequest.Key)
  return _internal_key();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GetRequest::set_key(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.key_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:raft_messages.GetRequest.Key)
}
inline std::string* GetRequest::mutable_key() {
  std::string* _s = _internal_mutable_key();
  // @@protoc_insertion_point(field_mutable:raft_messages.GetRequest.Key)
  return _s;
}
inline const std::string& GetRequest::_internal_key() const {
  return _impl_.key_.Get();
}
inline void GetRequest::_internal_set_key(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;


  _impl_.key_.Set(value, GetArenaForAllocation());
}
inline std::string* GetRequest::_internal_mutable_key() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.key_.Mutable( GetArenaForAllocation());
}
inline std::string* GetRequest::release_key() {
  // @@protoc_insertion_point(field_release:raft_messages.GetRequest.Key)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.key_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.key_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void GetRequest::set_allocated_key(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.key_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.key_.IsDefault()) {
          _impl_.key_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:raft_messages.GetRequest.Key)
}

// required int64 ClerkID = 2;
inline bool GetRequest::has_clerkid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void GetRequest::clear_clerkid() {
  _impl_.clerkid_ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::int64_t GetRequest::clerkid() const {
  // @@protoc_insertion_point(field_get:raft_messages.GetRequest.ClerkID)
  return _internal_clerkid();
}
inline void GetRequest::set_clerkid(::int64_t value) {
  _internal_set_clerkid(value);
  // @@protoc_insertion_point(field_set:raft_messages.GetRequest.ClerkID)
}
inline ::int64_t GetRequest::_internal_clerkid() const {
  return _impl_.clerkid_;
}
inline void GetRequest::_internal_set_clerkid(::int64_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.clerkid_ = value;
}

// required int64 CmdIndex = 3;
inline bool GetRequest::has_cmdindex() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void GetRequest::clear_cmdindex() {
  _impl_.cmdindex_ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::int64_t GetRequest::cmdindex() const {
  // @@protoc_insertion_point(field_get:raft_messages.GetRequest.CmdIndex)
  return _internal_cmdindex();
}
inline void GetRequest::set_cmdindex(::int64_t value) {
  _internal_set_cmdindex(value);
  // @@protoc_insertion_point(field_set:raft_messages.GetRequest.CmdIndex)
}
inline ::int64_t GetRequest::_internal_cmdindex() const {
  return _impl_.cmdindex_;
}
inline void GetRequest::_internal_set_cmdindex(::int64_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.cmdindex_ = value;
}

// -------------------------------------------------------------------

// GetResponse

// required bool WrongLeader = 1;
inline bool GetResponse::has_wrongleader() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void GetResponse::clear_wrongleader() {
  _impl_.wrongleader_ = false;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline bool GetResponse::wrongleader() const {
  // @@protoc_insertion_point(field_get:raft_messages.GetResponse.WrongLeader)
  return _internal_wrongleader();
}
inline void GetResponse::set_wrongleader(bool value) {
  _internal_set_wrongleader(value);
  // @@protoc_insertion_point(field_set:raft_messages.GetResponse.WrongLeader)
}
inline bool GetResponse::_internal_wrongleader() const {
  return _impl_.wrongleader_;
}
inline void GetResponse::_internal_set_wrongleader(bool value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.wrongleader_ = value;
}

// required string Err = 2;
inline bool GetResponse::has_err() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void GetResponse::clear_err() {
  _impl_.err_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& GetResponse::err() const {
  // @@protoc_insertion_point(field_get:raft_messages.GetResponse.Err)
  return _internal_err();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GetResponse::set_err(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.err_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:raft_messages.GetResponse.Err)
}
inline std::string* GetResponse::mutable_err() {
  std::string* _s = _internal_mutable_err();
  // @@protoc_insertion_point(field_mutable:raft_messages.GetResponse.Err)
  return _s;
}
inline const std::string& GetResponse::_internal_err() const {
  return _impl_.err_.Get();
}
inline void GetResponse::_internal_set_err(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;


  _impl_.err_.Set(value, GetArenaForAllocation());
}
inline std::string* GetResponse::_internal_mutable_err() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.err_.Mutable( GetArenaForAllocation());
}
inline std::string* GetResponse::release_err() {
  // @@protoc_insertion_point(field_release:raft_messages.GetResponse.Err)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.err_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.err_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void GetResponse::set_allocated_err(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.err_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.err_.IsDefault()) {
          _impl_.err_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:raft_messages.GetResponse.Err)
}

// required string Value = 3;
inline bool GetResponse::has_value() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void GetResponse::clear_value() {
  _impl_.value_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& GetResponse::value() const {
  // @@protoc_insertion_point(field_get:raft_messages.GetResponse.Value)
  return _internal_value();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GetResponse::set_value(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.value_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:raft_messages.GetResponse.Value)
}
inline std::string* GetResponse::mutable_value() {
  std::string* _s = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:raft_messages.GetResponse.Value)
  return _s;
}
inline const std::string& GetResponse::_internal_value() const {
  return _impl_.value_.Get();
}
inline void GetResponse::_internal_set_value(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;


  _impl_.value_.Set(value, GetArenaForAllocation());
}
inline std::string* GetResponse::_internal_mutable_value() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.value_.Mutable( GetArenaForAllocation());
}
inline std::string* GetResponse::release_value() {
  // @@protoc_insertion_point(field_release:raft_messages.GetResponse.Value)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.value_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.value_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void GetResponse::set_allocated_value(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.value_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.value_.IsDefault()) {
          _impl_.value_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:raft_messages.GetResponse.Value)
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace raft_messages


// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_raft_5fmessages_2eproto_2epb_2eh
